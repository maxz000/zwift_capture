// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protos/zwift_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Meetup {
    // message fields
    pub id: i32,
    pub tag2: i32,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub start_time: i64,
    pub distance: u32,
    pub tag8: i32,
    pub meetup_inner: ::protobuf::SingularPtrField<Meetup_MeetupInner>,
    pub thumbnail: ::std::string::String,
    pub duration: i32,
    pub f14: i64,
    pub f17: i32,
    pub f18: i32,
    pub f22: i32,
    pub f23: i32,
    pub meetup_only_view: i32,
    pub f25: i32,
    pub f27: i32,
    pub f28: i32,
    pub f29: i32,
    pub f34: i32,
    pub f35: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Meetup {
    fn default() -> &'a Meetup {
        <Meetup as ::protobuf::Message>::default_instance()
    }
}

impl Meetup {
    pub fn new() -> Meetup {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // int32 tag2 = 2;


    pub fn get_tag2(&self) -> i32 {
        self.tag2
    }
    pub fn clear_tag2(&mut self) {
        self.tag2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag2(&mut self, v: i32) {
        self.tag2 = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // int64 start_time = 5;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // fixed32 distance = 7;


    pub fn get_distance(&self) -> u32 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: u32) {
        self.distance = v;
    }

    // int32 tag8 = 8;


    pub fn get_tag8(&self) -> i32 {
        self.tag8
    }
    pub fn clear_tag8(&mut self) {
        self.tag8 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag8(&mut self, v: i32) {
        self.tag8 = v;
    }

    // .ZwiftPacketMonitor.Meetup.MeetupInner meetup_inner = 10;


    pub fn get_meetup_inner(&self) -> &Meetup_MeetupInner {
        self.meetup_inner.as_ref().unwrap_or_else(|| <Meetup_MeetupInner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_meetup_inner(&mut self) {
        self.meetup_inner.clear();
    }

    pub fn has_meetup_inner(&self) -> bool {
        self.meetup_inner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meetup_inner(&mut self, v: Meetup_MeetupInner) {
        self.meetup_inner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_meetup_inner(&mut self) -> &mut Meetup_MeetupInner {
        if self.meetup_inner.is_none() {
            self.meetup_inner.set_default();
        }
        self.meetup_inner.as_mut().unwrap()
    }

    // Take field
    pub fn take_meetup_inner(&mut self) -> Meetup_MeetupInner {
        self.meetup_inner.take().unwrap_or_else(|| Meetup_MeetupInner::new())
    }

    // string thumbnail = 12;


    pub fn get_thumbnail(&self) -> &str {
        &self.thumbnail
    }
    pub fn clear_thumbnail(&mut self) {
        self.thumbnail.clear();
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: ::std::string::String) {
        self.thumbnail = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut ::std::string::String {
        &mut self.thumbnail
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.thumbnail, ::std::string::String::new())
    }

    // int32 duration = 13;


    pub fn get_duration(&self) -> i32 {
        self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = v;
    }

    // int64 f14 = 14;


    pub fn get_f14(&self) -> i64 {
        self.f14
    }
    pub fn clear_f14(&mut self) {
        self.f14 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f14(&mut self, v: i64) {
        self.f14 = v;
    }

    // int32 f17 = 17;


    pub fn get_f17(&self) -> i32 {
        self.f17
    }
    pub fn clear_f17(&mut self) {
        self.f17 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f17(&mut self, v: i32) {
        self.f17 = v;
    }

    // int32 f18 = 18;


    pub fn get_f18(&self) -> i32 {
        self.f18
    }
    pub fn clear_f18(&mut self) {
        self.f18 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f18(&mut self, v: i32) {
        self.f18 = v;
    }

    // int32 f22 = 22;


    pub fn get_f22(&self) -> i32 {
        self.f22
    }
    pub fn clear_f22(&mut self) {
        self.f22 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f22(&mut self, v: i32) {
        self.f22 = v;
    }

    // int32 f23 = 23;


    pub fn get_f23(&self) -> i32 {
        self.f23
    }
    pub fn clear_f23(&mut self) {
        self.f23 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f23(&mut self, v: i32) {
        self.f23 = v;
    }

    // int32 meetup_only_view = 24;


    pub fn get_meetup_only_view(&self) -> i32 {
        self.meetup_only_view
    }
    pub fn clear_meetup_only_view(&mut self) {
        self.meetup_only_view = 0;
    }

    // Param is passed by value, moved
    pub fn set_meetup_only_view(&mut self, v: i32) {
        self.meetup_only_view = v;
    }

    // int32 f25 = 25;


    pub fn get_f25(&self) -> i32 {
        self.f25
    }
    pub fn clear_f25(&mut self) {
        self.f25 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f25(&mut self, v: i32) {
        self.f25 = v;
    }

    // int32 f27 = 27;


    pub fn get_f27(&self) -> i32 {
        self.f27
    }
    pub fn clear_f27(&mut self) {
        self.f27 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f27(&mut self, v: i32) {
        self.f27 = v;
    }

    // int32 f28 = 28;


    pub fn get_f28(&self) -> i32 {
        self.f28
    }
    pub fn clear_f28(&mut self) {
        self.f28 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f28(&mut self, v: i32) {
        self.f28 = v;
    }

    // int32 f29 = 29;


    pub fn get_f29(&self) -> i32 {
        self.f29
    }
    pub fn clear_f29(&mut self) {
        self.f29 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f29(&mut self, v: i32) {
        self.f29 = v;
    }

    // int32 f34 = 34;


    pub fn get_f34(&self) -> i32 {
        self.f34
    }
    pub fn clear_f34(&mut self) {
        self.f34 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f34(&mut self, v: i32) {
        self.f34 = v;
    }

    // int32 f35 = 35;


    pub fn get_f35(&self) -> i32 {
        self.f35
    }
    pub fn clear_f35(&mut self) {
        self.f35 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f35(&mut self, v: i32) {
        self.f35 = v;
    }
}

impl ::protobuf::Message for Meetup {
    fn is_initialized(&self) -> bool {
        for v in &self.meetup_inner {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tag2 = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.distance = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tag8 = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.meetup_inner)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.thumbnail)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f14 = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f17 = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f18 = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f22 = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f23 = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.meetup_only_view = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f25 = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f27 = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f28 = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f29 = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f34 = tmp;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f35 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tag2, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.distance != 0 {
            my_size += 5;
        }
        if self.tag8 != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tag8, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.meetup_inner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.thumbnail.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.thumbnail);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(13, self.duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f14 != 0 {
            my_size += ::protobuf::rt::value_size(14, self.f14, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f17 != 0 {
            my_size += ::protobuf::rt::value_size(17, self.f17, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f18 != 0 {
            my_size += ::protobuf::rt::value_size(18, self.f18, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f22 != 0 {
            my_size += ::protobuf::rt::value_size(22, self.f22, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f23 != 0 {
            my_size += ::protobuf::rt::value_size(23, self.f23, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.meetup_only_view != 0 {
            my_size += ::protobuf::rt::value_size(24, self.meetup_only_view, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f25 != 0 {
            my_size += ::protobuf::rt::value_size(25, self.f25, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f27 != 0 {
            my_size += ::protobuf::rt::value_size(27, self.f27, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f28 != 0 {
            my_size += ::protobuf::rt::value_size(28, self.f28, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f29 != 0 {
            my_size += ::protobuf::rt::value_size(29, self.f29, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f34 != 0 {
            my_size += ::protobuf::rt::value_size(34, self.f34, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f35 != 0 {
            my_size += ::protobuf::rt::value_size(35, self.f35, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.tag2 != 0 {
            os.write_int32(2, self.tag2)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if self.start_time != 0 {
            os.write_int64(5, self.start_time)?;
        }
        if self.distance != 0 {
            os.write_fixed32(7, self.distance)?;
        }
        if self.tag8 != 0 {
            os.write_int32(8, self.tag8)?;
        }
        if let Some(ref v) = self.meetup_inner.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.thumbnail.is_empty() {
            os.write_string(12, &self.thumbnail)?;
        }
        if self.duration != 0 {
            os.write_int32(13, self.duration)?;
        }
        if self.f14 != 0 {
            os.write_int64(14, self.f14)?;
        }
        if self.f17 != 0 {
            os.write_int32(17, self.f17)?;
        }
        if self.f18 != 0 {
            os.write_int32(18, self.f18)?;
        }
        if self.f22 != 0 {
            os.write_int32(22, self.f22)?;
        }
        if self.f23 != 0 {
            os.write_int32(23, self.f23)?;
        }
        if self.meetup_only_view != 0 {
            os.write_int32(24, self.meetup_only_view)?;
        }
        if self.f25 != 0 {
            os.write_int32(25, self.f25)?;
        }
        if self.f27 != 0 {
            os.write_int32(27, self.f27)?;
        }
        if self.f28 != 0 {
            os.write_int32(28, self.f28)?;
        }
        if self.f29 != 0 {
            os.write_int32(29, self.f29)?;
        }
        if self.f34 != 0 {
            os.write_int32(34, self.f34)?;
        }
        if self.f35 != 0 {
            os.write_int32(35, self.f35)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Meetup {
        Meetup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Meetup| { &m.id },
                |m: &mut Meetup| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tag2",
                |m: &Meetup| { &m.tag2 },
                |m: &mut Meetup| { &mut m.tag2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Meetup| { &m.name },
                |m: &mut Meetup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Meetup| { &m.description },
                |m: &mut Meetup| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_time",
                |m: &Meetup| { &m.start_time },
                |m: &mut Meetup| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "distance",
                |m: &Meetup| { &m.distance },
                |m: &mut Meetup| { &mut m.distance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tag8",
                |m: &Meetup| { &m.tag8 },
                |m: &mut Meetup| { &mut m.tag8 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Meetup_MeetupInner>>(
                "meetup_inner",
                |m: &Meetup| { &m.meetup_inner },
                |m: &mut Meetup| { &mut m.meetup_inner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail",
                |m: &Meetup| { &m.thumbnail },
                |m: &mut Meetup| { &mut m.thumbnail },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &Meetup| { &m.duration },
                |m: &mut Meetup| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f14",
                |m: &Meetup| { &m.f14 },
                |m: &mut Meetup| { &mut m.f14 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f17",
                |m: &Meetup| { &m.f17 },
                |m: &mut Meetup| { &mut m.f17 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f18",
                |m: &Meetup| { &m.f18 },
                |m: &mut Meetup| { &mut m.f18 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f22",
                |m: &Meetup| { &m.f22 },
                |m: &mut Meetup| { &mut m.f22 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f23",
                |m: &Meetup| { &m.f23 },
                |m: &mut Meetup| { &mut m.f23 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "meetup_only_view",
                |m: &Meetup| { &m.meetup_only_view },
                |m: &mut Meetup| { &mut m.meetup_only_view },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f25",
                |m: &Meetup| { &m.f25 },
                |m: &mut Meetup| { &mut m.f25 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f27",
                |m: &Meetup| { &m.f27 },
                |m: &mut Meetup| { &mut m.f27 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f28",
                |m: &Meetup| { &m.f28 },
                |m: &mut Meetup| { &mut m.f28 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f29",
                |m: &Meetup| { &m.f29 },
                |m: &mut Meetup| { &mut m.f29 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f34",
                |m: &Meetup| { &m.f34 },
                |m: &mut Meetup| { &mut m.f34 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f35",
                |m: &Meetup| { &m.f35 },
                |m: &mut Meetup| { &mut m.f35 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Meetup>(
                "Meetup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Meetup {
        static instance: ::protobuf::rt::LazyV2<Meetup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Meetup::new)
    }
}

impl ::protobuf::Clear for Meetup {
    fn clear(&mut self) {
        self.id = 0;
        self.tag2 = 0;
        self.name.clear();
        self.description.clear();
        self.start_time = 0;
        self.distance = 0;
        self.tag8 = 0;
        self.meetup_inner.clear();
        self.thumbnail.clear();
        self.duration = 0;
        self.f14 = 0;
        self.f17 = 0;
        self.f18 = 0;
        self.f22 = 0;
        self.f23 = 0;
        self.meetup_only_view = 0;
        self.f25 = 0;
        self.f27 = 0;
        self.f28 = 0;
        self.f29 = 0;
        self.f34 = 0;
        self.f35 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Meetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Meetup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Meetup_MeetupInner {
    // message fields
    pub id: i32,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub f7: ::std::string::String,
    pub f8: i64,
    pub f9: i64,
    pub f10: i64,
    pub f11: i64,
    pub f12: i64,
    pub f13: i64,
    pub f14: i64,
    pub f15: i64,
    pub f16: i64,
    pub f17: i64,
    pub f18: i64,
    pub f22: i64,
    pub distance: u32,
    pub f25: i64,
    pub f29: i32,
    pub f30: i32,
    pub f31: i32,
    pub f32: u32,
    pub f33: u32,
    pub duration: i32,
    pub f42: i64,
    pub f44: i64,
    pub f46: i32,
    pub f47: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Meetup_MeetupInner {
    fn default() -> &'a Meetup_MeetupInner {
        <Meetup_MeetupInner as ::protobuf::Message>::default_instance()
    }
}

impl Meetup_MeetupInner {
    pub fn new() -> Meetup_MeetupInner {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string f7 = 7;


    pub fn get_f7(&self) -> &str {
        &self.f7
    }
    pub fn clear_f7(&mut self) {
        self.f7.clear();
    }

    // Param is passed by value, moved
    pub fn set_f7(&mut self, v: ::std::string::String) {
        self.f7 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_f7(&mut self) -> &mut ::std::string::String {
        &mut self.f7
    }

    // Take field
    pub fn take_f7(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.f7, ::std::string::String::new())
    }

    // int64 f8 = 8;


    pub fn get_f8(&self) -> i64 {
        self.f8
    }
    pub fn clear_f8(&mut self) {
        self.f8 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f8(&mut self, v: i64) {
        self.f8 = v;
    }

    // int64 f9 = 9;


    pub fn get_f9(&self) -> i64 {
        self.f9
    }
    pub fn clear_f9(&mut self) {
        self.f9 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f9(&mut self, v: i64) {
        self.f9 = v;
    }

    // int64 f10 = 10;


    pub fn get_f10(&self) -> i64 {
        self.f10
    }
    pub fn clear_f10(&mut self) {
        self.f10 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f10(&mut self, v: i64) {
        self.f10 = v;
    }

    // int64 f11 = 11;


    pub fn get_f11(&self) -> i64 {
        self.f11
    }
    pub fn clear_f11(&mut self) {
        self.f11 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f11(&mut self, v: i64) {
        self.f11 = v;
    }

    // int64 f12 = 12;


    pub fn get_f12(&self) -> i64 {
        self.f12
    }
    pub fn clear_f12(&mut self) {
        self.f12 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f12(&mut self, v: i64) {
        self.f12 = v;
    }

    // int64 f13 = 13;


    pub fn get_f13(&self) -> i64 {
        self.f13
    }
    pub fn clear_f13(&mut self) {
        self.f13 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f13(&mut self, v: i64) {
        self.f13 = v;
    }

    // int64 f14 = 14;


    pub fn get_f14(&self) -> i64 {
        self.f14
    }
    pub fn clear_f14(&mut self) {
        self.f14 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f14(&mut self, v: i64) {
        self.f14 = v;
    }

    // int64 f15 = 15;


    pub fn get_f15(&self) -> i64 {
        self.f15
    }
    pub fn clear_f15(&mut self) {
        self.f15 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f15(&mut self, v: i64) {
        self.f15 = v;
    }

    // int64 f16 = 16;


    pub fn get_f16(&self) -> i64 {
        self.f16
    }
    pub fn clear_f16(&mut self) {
        self.f16 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f16(&mut self, v: i64) {
        self.f16 = v;
    }

    // int64 f17 = 17;


    pub fn get_f17(&self) -> i64 {
        self.f17
    }
    pub fn clear_f17(&mut self) {
        self.f17 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f17(&mut self, v: i64) {
        self.f17 = v;
    }

    // int64 f18 = 18;


    pub fn get_f18(&self) -> i64 {
        self.f18
    }
    pub fn clear_f18(&mut self) {
        self.f18 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f18(&mut self, v: i64) {
        self.f18 = v;
    }

    // int64 f22 = 22;


    pub fn get_f22(&self) -> i64 {
        self.f22
    }
    pub fn clear_f22(&mut self) {
        self.f22 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f22(&mut self, v: i64) {
        self.f22 = v;
    }

    // fixed32 distance = 24;


    pub fn get_distance(&self) -> u32 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: u32) {
        self.distance = v;
    }

    // int64 f25 = 25;


    pub fn get_f25(&self) -> i64 {
        self.f25
    }
    pub fn clear_f25(&mut self) {
        self.f25 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f25(&mut self, v: i64) {
        self.f25 = v;
    }

    // int32 f29 = 29;


    pub fn get_f29(&self) -> i32 {
        self.f29
    }
    pub fn clear_f29(&mut self) {
        self.f29 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f29(&mut self, v: i32) {
        self.f29 = v;
    }

    // int32 f30 = 30;


    pub fn get_f30(&self) -> i32 {
        self.f30
    }
    pub fn clear_f30(&mut self) {
        self.f30 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f30(&mut self, v: i32) {
        self.f30 = v;
    }

    // int32 f31 = 31;


    pub fn get_f31(&self) -> i32 {
        self.f31
    }
    pub fn clear_f31(&mut self) {
        self.f31 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f31(&mut self, v: i32) {
        self.f31 = v;
    }

    // fixed32 f32 = 32;


    pub fn get_f32(&self) -> u32 {
        self.f32
    }
    pub fn clear_f32(&mut self) {
        self.f32 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f32(&mut self, v: u32) {
        self.f32 = v;
    }

    // fixed32 f33 = 33;


    pub fn get_f33(&self) -> u32 {
        self.f33
    }
    pub fn clear_f33(&mut self) {
        self.f33 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f33(&mut self, v: u32) {
        self.f33 = v;
    }

    // int32 duration = 34;


    pub fn get_duration(&self) -> i32 {
        self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = v;
    }

    // int64 f42 = 42;


    pub fn get_f42(&self) -> i64 {
        self.f42
    }
    pub fn clear_f42(&mut self) {
        self.f42 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f42(&mut self, v: i64) {
        self.f42 = v;
    }

    // int64 f44 = 44;


    pub fn get_f44(&self) -> i64 {
        self.f44
    }
    pub fn clear_f44(&mut self) {
        self.f44 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f44(&mut self, v: i64) {
        self.f44 = v;
    }

    // int32 f46 = 46;


    pub fn get_f46(&self) -> i32 {
        self.f46
    }
    pub fn clear_f46(&mut self) {
        self.f46 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f46(&mut self, v: i32) {
        self.f46 = v;
    }

    // int32 f47 = 47;


    pub fn get_f47(&self) -> i32 {
        self.f47
    }
    pub fn clear_f47(&mut self) {
        self.f47 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f47(&mut self, v: i32) {
        self.f47 = v;
    }
}

impl ::protobuf::Message for Meetup_MeetupInner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.f7)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f8 = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f9 = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f10 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f11 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f12 = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f13 = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f14 = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f15 = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f16 = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f17 = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f18 = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f22 = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.distance = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f25 = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f29 = tmp;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f30 = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f31 = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.f32 = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.f33 = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f42 = tmp;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f44 = tmp;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f46 = tmp;
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f47 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.f7.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.f7);
        }
        if self.f8 != 0 {
            my_size += ::protobuf::rt::value_size(8, self.f8, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f9 != 0 {
            my_size += ::protobuf::rt::value_size(9, self.f9, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f10 != 0 {
            my_size += ::protobuf::rt::value_size(10, self.f10, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f11 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.f11, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f12 != 0 {
            my_size += ::protobuf::rt::value_size(12, self.f12, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f13 != 0 {
            my_size += ::protobuf::rt::value_size(13, self.f13, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f14 != 0 {
            my_size += ::protobuf::rt::value_size(14, self.f14, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f15 != 0 {
            my_size += ::protobuf::rt::value_size(15, self.f15, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f16 != 0 {
            my_size += ::protobuf::rt::value_size(16, self.f16, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f17 != 0 {
            my_size += ::protobuf::rt::value_size(17, self.f17, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f18 != 0 {
            my_size += ::protobuf::rt::value_size(18, self.f18, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f22 != 0 {
            my_size += ::protobuf::rt::value_size(22, self.f22, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.distance != 0 {
            my_size += 6;
        }
        if self.f25 != 0 {
            my_size += ::protobuf::rt::value_size(25, self.f25, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f29 != 0 {
            my_size += ::protobuf::rt::value_size(29, self.f29, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f30 != 0 {
            my_size += ::protobuf::rt::value_size(30, self.f30, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f31 != 0 {
            my_size += ::protobuf::rt::value_size(31, self.f31, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f32 != 0 {
            my_size += 6;
        }
        if self.f33 != 0 {
            my_size += 6;
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(34, self.duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f42 != 0 {
            my_size += ::protobuf::rt::value_size(42, self.f42, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f44 != 0 {
            my_size += ::protobuf::rt::value_size(44, self.f44, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f46 != 0 {
            my_size += ::protobuf::rt::value_size(46, self.f46, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f47 != 0 {
            my_size += ::protobuf::rt::value_size(47, self.f47, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.f7.is_empty() {
            os.write_string(7, &self.f7)?;
        }
        if self.f8 != 0 {
            os.write_int64(8, self.f8)?;
        }
        if self.f9 != 0 {
            os.write_int64(9, self.f9)?;
        }
        if self.f10 != 0 {
            os.write_int64(10, self.f10)?;
        }
        if self.f11 != 0 {
            os.write_int64(11, self.f11)?;
        }
        if self.f12 != 0 {
            os.write_int64(12, self.f12)?;
        }
        if self.f13 != 0 {
            os.write_int64(13, self.f13)?;
        }
        if self.f14 != 0 {
            os.write_int64(14, self.f14)?;
        }
        if self.f15 != 0 {
            os.write_int64(15, self.f15)?;
        }
        if self.f16 != 0 {
            os.write_int64(16, self.f16)?;
        }
        if self.f17 != 0 {
            os.write_int64(17, self.f17)?;
        }
        if self.f18 != 0 {
            os.write_int64(18, self.f18)?;
        }
        if self.f22 != 0 {
            os.write_int64(22, self.f22)?;
        }
        if self.distance != 0 {
            os.write_fixed32(24, self.distance)?;
        }
        if self.f25 != 0 {
            os.write_int64(25, self.f25)?;
        }
        if self.f29 != 0 {
            os.write_int32(29, self.f29)?;
        }
        if self.f30 != 0 {
            os.write_int32(30, self.f30)?;
        }
        if self.f31 != 0 {
            os.write_int32(31, self.f31)?;
        }
        if self.f32 != 0 {
            os.write_fixed32(32, self.f32)?;
        }
        if self.f33 != 0 {
            os.write_fixed32(33, self.f33)?;
        }
        if self.duration != 0 {
            os.write_int32(34, self.duration)?;
        }
        if self.f42 != 0 {
            os.write_int64(42, self.f42)?;
        }
        if self.f44 != 0 {
            os.write_int64(44, self.f44)?;
        }
        if self.f46 != 0 {
            os.write_int32(46, self.f46)?;
        }
        if self.f47 != 0 {
            os.write_int32(47, self.f47)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Meetup_MeetupInner {
        Meetup_MeetupInner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Meetup_MeetupInner| { &m.id },
                |m: &mut Meetup_MeetupInner| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Meetup_MeetupInner| { &m.name },
                |m: &mut Meetup_MeetupInner| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Meetup_MeetupInner| { &m.description },
                |m: &mut Meetup_MeetupInner| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "f7",
                |m: &Meetup_MeetupInner| { &m.f7 },
                |m: &mut Meetup_MeetupInner| { &mut m.f7 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f8",
                |m: &Meetup_MeetupInner| { &m.f8 },
                |m: &mut Meetup_MeetupInner| { &mut m.f8 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f9",
                |m: &Meetup_MeetupInner| { &m.f9 },
                |m: &mut Meetup_MeetupInner| { &mut m.f9 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f10",
                |m: &Meetup_MeetupInner| { &m.f10 },
                |m: &mut Meetup_MeetupInner| { &mut m.f10 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f11",
                |m: &Meetup_MeetupInner| { &m.f11 },
                |m: &mut Meetup_MeetupInner| { &mut m.f11 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f12",
                |m: &Meetup_MeetupInner| { &m.f12 },
                |m: &mut Meetup_MeetupInner| { &mut m.f12 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f13",
                |m: &Meetup_MeetupInner| { &m.f13 },
                |m: &mut Meetup_MeetupInner| { &mut m.f13 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f14",
                |m: &Meetup_MeetupInner| { &m.f14 },
                |m: &mut Meetup_MeetupInner| { &mut m.f14 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f15",
                |m: &Meetup_MeetupInner| { &m.f15 },
                |m: &mut Meetup_MeetupInner| { &mut m.f15 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f16",
                |m: &Meetup_MeetupInner| { &m.f16 },
                |m: &mut Meetup_MeetupInner| { &mut m.f16 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f17",
                |m: &Meetup_MeetupInner| { &m.f17 },
                |m: &mut Meetup_MeetupInner| { &mut m.f17 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f18",
                |m: &Meetup_MeetupInner| { &m.f18 },
                |m: &mut Meetup_MeetupInner| { &mut m.f18 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f22",
                |m: &Meetup_MeetupInner| { &m.f22 },
                |m: &mut Meetup_MeetupInner| { &mut m.f22 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "distance",
                |m: &Meetup_MeetupInner| { &m.distance },
                |m: &mut Meetup_MeetupInner| { &mut m.distance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f25",
                |m: &Meetup_MeetupInner| { &m.f25 },
                |m: &mut Meetup_MeetupInner| { &mut m.f25 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f29",
                |m: &Meetup_MeetupInner| { &m.f29 },
                |m: &mut Meetup_MeetupInner| { &mut m.f29 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f30",
                |m: &Meetup_MeetupInner| { &m.f30 },
                |m: &mut Meetup_MeetupInner| { &mut m.f30 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f31",
                |m: &Meetup_MeetupInner| { &m.f31 },
                |m: &mut Meetup_MeetupInner| { &mut m.f31 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "f32",
                |m: &Meetup_MeetupInner| { &m.f32 },
                |m: &mut Meetup_MeetupInner| { &mut m.f32 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "f33",
                |m: &Meetup_MeetupInner| { &m.f33 },
                |m: &mut Meetup_MeetupInner| { &mut m.f33 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &Meetup_MeetupInner| { &m.duration },
                |m: &mut Meetup_MeetupInner| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f42",
                |m: &Meetup_MeetupInner| { &m.f42 },
                |m: &mut Meetup_MeetupInner| { &mut m.f42 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f44",
                |m: &Meetup_MeetupInner| { &m.f44 },
                |m: &mut Meetup_MeetupInner| { &mut m.f44 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f46",
                |m: &Meetup_MeetupInner| { &m.f46 },
                |m: &mut Meetup_MeetupInner| { &mut m.f46 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f47",
                |m: &Meetup_MeetupInner| { &m.f47 },
                |m: &mut Meetup_MeetupInner| { &mut m.f47 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Meetup_MeetupInner>(
                "Meetup.MeetupInner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Meetup_MeetupInner {
        static instance: ::protobuf::rt::LazyV2<Meetup_MeetupInner> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Meetup_MeetupInner::new)
    }
}

impl ::protobuf::Clear for Meetup_MeetupInner {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.description.clear();
        self.f7.clear();
        self.f8 = 0;
        self.f9 = 0;
        self.f10 = 0;
        self.f11 = 0;
        self.f12 = 0;
        self.f13 = 0;
        self.f14 = 0;
        self.f15 = 0;
        self.f16 = 0;
        self.f17 = 0;
        self.f18 = 0;
        self.f22 = 0;
        self.distance = 0;
        self.f25 = 0;
        self.f29 = 0;
        self.f30 = 0;
        self.f31 = 0;
        self.f32 = 0;
        self.f33 = 0;
        self.duration = 0;
        self.f42 = 0;
        self.f44 = 0;
        self.f46 = 0;
        self.f47 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Meetup_MeetupInner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Meetup_MeetupInner {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerState {
    // message fields
    pub id: i32,
    pub worldTime: i64,
    pub distance: i32,
    pub roadTime: i32,
    pub laps: i32,
    pub speed: i32,
    pub roadPosition: i32,
    pub cadenceUHz: i32,
    pub heartrate: i32,
    pub power: i32,
    pub heading: i64,
    pub lean: i32,
    pub climbing: i32,
    pub time: i32,
    pub f19: i32,
    pub f20: i32,
    pub progress: i32,
    pub customisationId: i64,
    pub justWatching: i32,
    pub calories: i32,
    pub x: f32,
    pub altitude: f32,
    pub y: f32,
    pub watchingRiderId: i32,
    pub groupId: i32,
    pub sport: i64,
    pub f34: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerState {
    fn default() -> &'a PlayerState {
        <PlayerState as ::protobuf::Message>::default_instance()
    }
}

impl PlayerState {
    pub fn new() -> PlayerState {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // int64 worldTime = 2;


    pub fn get_worldTime(&self) -> i64 {
        self.worldTime
    }
    pub fn clear_worldTime(&mut self) {
        self.worldTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_worldTime(&mut self, v: i64) {
        self.worldTime = v;
    }

    // int32 distance = 3;


    pub fn get_distance(&self) -> i32 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: i32) {
        self.distance = v;
    }

    // int32 roadTime = 4;


    pub fn get_roadTime(&self) -> i32 {
        self.roadTime
    }
    pub fn clear_roadTime(&mut self) {
        self.roadTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_roadTime(&mut self, v: i32) {
        self.roadTime = v;
    }

    // int32 laps = 5;


    pub fn get_laps(&self) -> i32 {
        self.laps
    }
    pub fn clear_laps(&mut self) {
        self.laps = 0;
    }

    // Param is passed by value, moved
    pub fn set_laps(&mut self, v: i32) {
        self.laps = v;
    }

    // int32 speed = 6;


    pub fn get_speed(&self) -> i32 {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = 0;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: i32) {
        self.speed = v;
    }

    // int32 roadPosition = 8;


    pub fn get_roadPosition(&self) -> i32 {
        self.roadPosition
    }
    pub fn clear_roadPosition(&mut self) {
        self.roadPosition = 0;
    }

    // Param is passed by value, moved
    pub fn set_roadPosition(&mut self, v: i32) {
        self.roadPosition = v;
    }

    // int32 cadenceUHz = 9;


    pub fn get_cadenceUHz(&self) -> i32 {
        self.cadenceUHz
    }
    pub fn clear_cadenceUHz(&mut self) {
        self.cadenceUHz = 0;
    }

    // Param is passed by value, moved
    pub fn set_cadenceUHz(&mut self, v: i32) {
        self.cadenceUHz = v;
    }

    // int32 heartrate = 11;


    pub fn get_heartrate(&self) -> i32 {
        self.heartrate
    }
    pub fn clear_heartrate(&mut self) {
        self.heartrate = 0;
    }

    // Param is passed by value, moved
    pub fn set_heartrate(&mut self, v: i32) {
        self.heartrate = v;
    }

    // int32 power = 12;


    pub fn get_power(&self) -> i32 {
        self.power
    }
    pub fn clear_power(&mut self) {
        self.power = 0;
    }

    // Param is passed by value, moved
    pub fn set_power(&mut self, v: i32) {
        self.power = v;
    }

    // int64 heading = 13;


    pub fn get_heading(&self) -> i64 {
        self.heading
    }
    pub fn clear_heading(&mut self) {
        self.heading = 0;
    }

    // Param is passed by value, moved
    pub fn set_heading(&mut self, v: i64) {
        self.heading = v;
    }

    // int32 lean = 14;


    pub fn get_lean(&self) -> i32 {
        self.lean
    }
    pub fn clear_lean(&mut self) {
        self.lean = 0;
    }

    // Param is passed by value, moved
    pub fn set_lean(&mut self, v: i32) {
        self.lean = v;
    }

    // int32 climbing = 15;


    pub fn get_climbing(&self) -> i32 {
        self.climbing
    }
    pub fn clear_climbing(&mut self) {
        self.climbing = 0;
    }

    // Param is passed by value, moved
    pub fn set_climbing(&mut self, v: i32) {
        self.climbing = v;
    }

    // int32 time = 16;


    pub fn get_time(&self) -> i32 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = v;
    }

    // int32 f19 = 19;


    pub fn get_f19(&self) -> i32 {
        self.f19
    }
    pub fn clear_f19(&mut self) {
        self.f19 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f19(&mut self, v: i32) {
        self.f19 = v;
    }

    // int32 f20 = 20;


    pub fn get_f20(&self) -> i32 {
        self.f20
    }
    pub fn clear_f20(&mut self) {
        self.f20 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f20(&mut self, v: i32) {
        self.f20 = v;
    }

    // int32 progress = 21;


    pub fn get_progress(&self) -> i32 {
        self.progress
    }
    pub fn clear_progress(&mut self) {
        self.progress = 0;
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = v;
    }

    // int64 customisationId = 22;


    pub fn get_customisationId(&self) -> i64 {
        self.customisationId
    }
    pub fn clear_customisationId(&mut self) {
        self.customisationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_customisationId(&mut self, v: i64) {
        self.customisationId = v;
    }

    // int32 justWatching = 23;


    pub fn get_justWatching(&self) -> i32 {
        self.justWatching
    }
    pub fn clear_justWatching(&mut self) {
        self.justWatching = 0;
    }

    // Param is passed by value, moved
    pub fn set_justWatching(&mut self, v: i32) {
        self.justWatching = v;
    }

    // int32 calories = 24;


    pub fn get_calories(&self) -> i32 {
        self.calories
    }
    pub fn clear_calories(&mut self) {
        self.calories = 0;
    }

    // Param is passed by value, moved
    pub fn set_calories(&mut self, v: i32) {
        self.calories = v;
    }

    // float x = 25;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float altitude = 26;


    pub fn get_altitude(&self) -> f32 {
        self.altitude
    }
    pub fn clear_altitude(&mut self) {
        self.altitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_altitude(&mut self, v: f32) {
        self.altitude = v;
    }

    // float y = 27;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // int32 watchingRiderId = 28;


    pub fn get_watchingRiderId(&self) -> i32 {
        self.watchingRiderId
    }
    pub fn clear_watchingRiderId(&mut self) {
        self.watchingRiderId = 0;
    }

    // Param is passed by value, moved
    pub fn set_watchingRiderId(&mut self, v: i32) {
        self.watchingRiderId = v;
    }

    // int32 groupId = 29;


    pub fn get_groupId(&self) -> i32 {
        self.groupId
    }
    pub fn clear_groupId(&mut self) {
        self.groupId = 0;
    }

    // Param is passed by value, moved
    pub fn set_groupId(&mut self, v: i32) {
        self.groupId = v;
    }

    // int64 sport = 31;


    pub fn get_sport(&self) -> i64 {
        self.sport
    }
    pub fn clear_sport(&mut self) {
        self.sport = 0;
    }

    // Param is passed by value, moved
    pub fn set_sport(&mut self, v: i64) {
        self.sport = v;
    }

    // float f34 = 34;


    pub fn get_f34(&self) -> f32 {
        self.f34
    }
    pub fn clear_f34(&mut self) {
        self.f34 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_f34(&mut self, v: f32) {
        self.f34 = v;
    }
}

impl ::protobuf::Message for PlayerState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.worldTime = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.distance = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.roadTime = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.laps = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.speed = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.roadPosition = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cadenceUHz = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.heartrate = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.power = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.heading = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lean = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.climbing = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f19 = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f20 = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.progress = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.customisationId = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.justWatching = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.calories = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.altitude = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.watchingRiderId = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupId = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sport = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.f34 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.worldTime != 0 {
            my_size += ::protobuf::rt::value_size(2, self.worldTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.distance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.distance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.roadTime != 0 {
            my_size += ::protobuf::rt::value_size(4, self.roadTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.laps != 0 {
            my_size += ::protobuf::rt::value_size(5, self.laps, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.speed != 0 {
            my_size += ::protobuf::rt::value_size(6, self.speed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.roadPosition != 0 {
            my_size += ::protobuf::rt::value_size(8, self.roadPosition, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cadenceUHz != 0 {
            my_size += ::protobuf::rt::value_size(9, self.cadenceUHz, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.heartrate != 0 {
            my_size += ::protobuf::rt::value_size(11, self.heartrate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.power != 0 {
            my_size += ::protobuf::rt::value_size(12, self.power, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.heading != 0 {
            my_size += ::protobuf::rt::value_size(13, self.heading, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lean != 0 {
            my_size += ::protobuf::rt::value_size(14, self.lean, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.climbing != 0 {
            my_size += ::protobuf::rt::value_size(15, self.climbing, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(16, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f19 != 0 {
            my_size += ::protobuf::rt::value_size(19, self.f19, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f20 != 0 {
            my_size += ::protobuf::rt::value_size(20, self.f20, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.progress != 0 {
            my_size += ::protobuf::rt::value_size(21, self.progress, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.customisationId != 0 {
            my_size += ::protobuf::rt::value_size(22, self.customisationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.justWatching != 0 {
            my_size += ::protobuf::rt::value_size(23, self.justWatching, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.calories != 0 {
            my_size += ::protobuf::rt::value_size(24, self.calories, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.x != 0. {
            my_size += 6;
        }
        if self.altitude != 0. {
            my_size += 6;
        }
        if self.y != 0. {
            my_size += 6;
        }
        if self.watchingRiderId != 0 {
            my_size += ::protobuf::rt::value_size(28, self.watchingRiderId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.groupId != 0 {
            my_size += ::protobuf::rt::value_size(29, self.groupId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sport != 0 {
            my_size += ::protobuf::rt::value_size(31, self.sport, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f34 != 0. {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.worldTime != 0 {
            os.write_int64(2, self.worldTime)?;
        }
        if self.distance != 0 {
            os.write_int32(3, self.distance)?;
        }
        if self.roadTime != 0 {
            os.write_int32(4, self.roadTime)?;
        }
        if self.laps != 0 {
            os.write_int32(5, self.laps)?;
        }
        if self.speed != 0 {
            os.write_int32(6, self.speed)?;
        }
        if self.roadPosition != 0 {
            os.write_int32(8, self.roadPosition)?;
        }
        if self.cadenceUHz != 0 {
            os.write_int32(9, self.cadenceUHz)?;
        }
        if self.heartrate != 0 {
            os.write_int32(11, self.heartrate)?;
        }
        if self.power != 0 {
            os.write_int32(12, self.power)?;
        }
        if self.heading != 0 {
            os.write_int64(13, self.heading)?;
        }
        if self.lean != 0 {
            os.write_int32(14, self.lean)?;
        }
        if self.climbing != 0 {
            os.write_int32(15, self.climbing)?;
        }
        if self.time != 0 {
            os.write_int32(16, self.time)?;
        }
        if self.f19 != 0 {
            os.write_int32(19, self.f19)?;
        }
        if self.f20 != 0 {
            os.write_int32(20, self.f20)?;
        }
        if self.progress != 0 {
            os.write_int32(21, self.progress)?;
        }
        if self.customisationId != 0 {
            os.write_int64(22, self.customisationId)?;
        }
        if self.justWatching != 0 {
            os.write_int32(23, self.justWatching)?;
        }
        if self.calories != 0 {
            os.write_int32(24, self.calories)?;
        }
        if self.x != 0. {
            os.write_float(25, self.x)?;
        }
        if self.altitude != 0. {
            os.write_float(26, self.altitude)?;
        }
        if self.y != 0. {
            os.write_float(27, self.y)?;
        }
        if self.watchingRiderId != 0 {
            os.write_int32(28, self.watchingRiderId)?;
        }
        if self.groupId != 0 {
            os.write_int32(29, self.groupId)?;
        }
        if self.sport != 0 {
            os.write_int64(31, self.sport)?;
        }
        if self.f34 != 0. {
            os.write_float(34, self.f34)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerState {
        PlayerState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &PlayerState| { &m.id },
                |m: &mut PlayerState| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "worldTime",
                |m: &PlayerState| { &m.worldTime },
                |m: &mut PlayerState| { &mut m.worldTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "distance",
                |m: &PlayerState| { &m.distance },
                |m: &mut PlayerState| { &mut m.distance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "roadTime",
                |m: &PlayerState| { &m.roadTime },
                |m: &mut PlayerState| { &mut m.roadTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "laps",
                |m: &PlayerState| { &m.laps },
                |m: &mut PlayerState| { &mut m.laps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "speed",
                |m: &PlayerState| { &m.speed },
                |m: &mut PlayerState| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "roadPosition",
                |m: &PlayerState| { &m.roadPosition },
                |m: &mut PlayerState| { &mut m.roadPosition },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cadenceUHz",
                |m: &PlayerState| { &m.cadenceUHz },
                |m: &mut PlayerState| { &mut m.cadenceUHz },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "heartrate",
                |m: &PlayerState| { &m.heartrate },
                |m: &mut PlayerState| { &mut m.heartrate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "power",
                |m: &PlayerState| { &m.power },
                |m: &mut PlayerState| { &mut m.power },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "heading",
                |m: &PlayerState| { &m.heading },
                |m: &mut PlayerState| { &mut m.heading },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lean",
                |m: &PlayerState| { &m.lean },
                |m: &mut PlayerState| { &mut m.lean },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "climbing",
                |m: &PlayerState| { &m.climbing },
                |m: &mut PlayerState| { &mut m.climbing },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "time",
                |m: &PlayerState| { &m.time },
                |m: &mut PlayerState| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f19",
                |m: &PlayerState| { &m.f19 },
                |m: &mut PlayerState| { &mut m.f19 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f20",
                |m: &PlayerState| { &m.f20 },
                |m: &mut PlayerState| { &mut m.f20 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "progress",
                |m: &PlayerState| { &m.progress },
                |m: &mut PlayerState| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "customisationId",
                |m: &PlayerState| { &m.customisationId },
                |m: &mut PlayerState| { &mut m.customisationId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "justWatching",
                |m: &PlayerState| { &m.justWatching },
                |m: &mut PlayerState| { &mut m.justWatching },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "calories",
                |m: &PlayerState| { &m.calories },
                |m: &mut PlayerState| { &mut m.calories },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &PlayerState| { &m.x },
                |m: &mut PlayerState| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "altitude",
                |m: &PlayerState| { &m.altitude },
                |m: &mut PlayerState| { &mut m.altitude },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &PlayerState| { &m.y },
                |m: &mut PlayerState| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "watchingRiderId",
                |m: &PlayerState| { &m.watchingRiderId },
                |m: &mut PlayerState| { &mut m.watchingRiderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "groupId",
                |m: &PlayerState| { &m.groupId },
                |m: &mut PlayerState| { &mut m.groupId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sport",
                |m: &PlayerState| { &m.sport },
                |m: &mut PlayerState| { &mut m.sport },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "f34",
                |m: &PlayerState| { &m.f34 },
                |m: &mut PlayerState| { &mut m.f34 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerState>(
                "PlayerState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerState {
        static instance: ::protobuf::rt::LazyV2<PlayerState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerState::new)
    }
}

impl ::protobuf::Clear for PlayerState {
    fn clear(&mut self) {
        self.id = 0;
        self.worldTime = 0;
        self.distance = 0;
        self.roadTime = 0;
        self.laps = 0;
        self.speed = 0;
        self.roadPosition = 0;
        self.cadenceUHz = 0;
        self.heartrate = 0;
        self.power = 0;
        self.heading = 0;
        self.lean = 0;
        self.climbing = 0;
        self.time = 0;
        self.f19 = 0;
        self.f20 = 0;
        self.progress = 0;
        self.customisationId = 0;
        self.justWatching = 0;
        self.calories = 0;
        self.x = 0.;
        self.altitude = 0.;
        self.y = 0.;
        self.watchingRiderId = 0;
        self.groupId = 0;
        self.sport = 0;
        self.f34 = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientToServer {
    // message fields
    pub connected: i32,
    pub rider_id: i32,
    pub world_time: i64,
    pub seqno: i32,
    pub state: ::protobuf::SingularPtrField<PlayerState>,
    pub tag8: i64,
    pub tag9: i64,
    pub last_update: i64,
    pub tag11: i64,
    pub last_player_update: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientToServer {
    fn default() -> &'a ClientToServer {
        <ClientToServer as ::protobuf::Message>::default_instance()
    }
}

impl ClientToServer {
    pub fn new() -> ClientToServer {
        ::std::default::Default::default()
    }

    // int32 connected = 1;


    pub fn get_connected(&self) -> i32 {
        self.connected
    }
    pub fn clear_connected(&mut self) {
        self.connected = 0;
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: i32) {
        self.connected = v;
    }

    // int32 rider_id = 2;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = v;
    }

    // int64 world_time = 3;


    pub fn get_world_time(&self) -> i64 {
        self.world_time
    }
    pub fn clear_world_time(&mut self) {
        self.world_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_world_time(&mut self, v: i64) {
        self.world_time = v;
    }

    // int32 seqno = 4;


    pub fn get_seqno(&self) -> i32 {
        self.seqno
    }
    pub fn clear_seqno(&mut self) {
        self.seqno = 0;
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i32) {
        self.seqno = v;
    }

    // .ZwiftPacketMonitor.PlayerState state = 7;


    pub fn get_state(&self) -> &PlayerState {
        self.state.as_ref().unwrap_or_else(|| <PlayerState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PlayerState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut PlayerState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> PlayerState {
        self.state.take().unwrap_or_else(|| PlayerState::new())
    }

    // int64 tag8 = 8;


    pub fn get_tag8(&self) -> i64 {
        self.tag8
    }
    pub fn clear_tag8(&mut self) {
        self.tag8 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag8(&mut self, v: i64) {
        self.tag8 = v;
    }

    // int64 tag9 = 9;


    pub fn get_tag9(&self) -> i64 {
        self.tag9
    }
    pub fn clear_tag9(&mut self) {
        self.tag9 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag9(&mut self, v: i64) {
        self.tag9 = v;
    }

    // int64 last_update = 10;


    pub fn get_last_update(&self) -> i64 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: i64) {
        self.last_update = v;
    }

    // int64 tag11 = 11;


    pub fn get_tag11(&self) -> i64 {
        self.tag11
    }
    pub fn clear_tag11(&mut self) {
        self.tag11 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag11(&mut self, v: i64) {
        self.tag11 = v;
    }

    // int64 last_player_update = 12;


    pub fn get_last_player_update(&self) -> i64 {
        self.last_player_update
    }
    pub fn clear_last_player_update(&mut self) {
        self.last_player_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_player_update(&mut self, v: i64) {
        self.last_player_update = v;
    }
}

impl ::protobuf::Message for ClientToServer {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connected = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.world_time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seqno = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag8 = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag9 = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_update = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag11 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_player_update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.connected != 0 {
            my_size += ::protobuf::rt::value_size(1, self.connected, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rider_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.world_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.world_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seqno != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seqno, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tag8 != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tag8, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag9 != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tag9, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(10, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag11 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.tag11, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_player_update != 0 {
            my_size += ::protobuf::rt::value_size(12, self.last_player_update, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.connected != 0 {
            os.write_int32(1, self.connected)?;
        }
        if self.rider_id != 0 {
            os.write_int32(2, self.rider_id)?;
        }
        if self.world_time != 0 {
            os.write_int64(3, self.world_time)?;
        }
        if self.seqno != 0 {
            os.write_int32(4, self.seqno)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tag8 != 0 {
            os.write_int64(8, self.tag8)?;
        }
        if self.tag9 != 0 {
            os.write_int64(9, self.tag9)?;
        }
        if self.last_update != 0 {
            os.write_int64(10, self.last_update)?;
        }
        if self.tag11 != 0 {
            os.write_int64(11, self.tag11)?;
        }
        if self.last_player_update != 0 {
            os.write_int64(12, self.last_player_update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientToServer {
        ClientToServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "connected",
                |m: &ClientToServer| { &m.connected },
                |m: &mut ClientToServer| { &mut m.connected },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &ClientToServer| { &m.rider_id },
                |m: &mut ClientToServer| { &mut m.rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "world_time",
                |m: &ClientToServer| { &m.world_time },
                |m: &mut ClientToServer| { &mut m.world_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seqno",
                |m: &ClientToServer| { &m.seqno },
                |m: &mut ClientToServer| { &mut m.seqno },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerState>>(
                "state",
                |m: &ClientToServer| { &m.state },
                |m: &mut ClientToServer| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag8",
                |m: &ClientToServer| { &m.tag8 },
                |m: &mut ClientToServer| { &mut m.tag8 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag9",
                |m: &ClientToServer| { &m.tag9 },
                |m: &mut ClientToServer| { &mut m.tag9 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_update",
                |m: &ClientToServer| { &m.last_update },
                |m: &mut ClientToServer| { &mut m.last_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag11",
                |m: &ClientToServer| { &m.tag11 },
                |m: &mut ClientToServer| { &mut m.tag11 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_player_update",
                |m: &ClientToServer| { &m.last_player_update },
                |m: &mut ClientToServer| { &mut m.last_player_update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientToServer>(
                "ClientToServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientToServer {
        static instance: ::protobuf::rt::LazyV2<ClientToServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientToServer::new)
    }
}

impl ::protobuf::Clear for ClientToServer {
    fn clear(&mut self) {
        self.connected = 0;
        self.rider_id = 0;
        self.world_time = 0;
        self.seqno = 0;
        self.state.clear();
        self.tag8 = 0;
        self.tag9 = 0;
        self.last_update = 0;
        self.tag11 = 0;
        self.last_player_update = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientToServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientToServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnknownMessage1 {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnknownMessage1 {
    fn default() -> &'a UnknownMessage1 {
        <UnknownMessage1 as ::protobuf::Message>::default_instance()
    }
}

impl UnknownMessage1 {
    pub fn new() -> UnknownMessage1 {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnknownMessage1 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnknownMessage1 {
        UnknownMessage1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnknownMessage1>(
                "UnknownMessage1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnknownMessage1 {
        static instance: ::protobuf::rt::LazyV2<UnknownMessage1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnknownMessage1::new)
    }
}

impl ::protobuf::Clear for UnknownMessage1 {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnknownMessage1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnknownMessage1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnknownMessage {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnknownMessage {
    fn default() -> &'a UnknownMessage {
        <UnknownMessage as ::protobuf::Message>::default_instance()
    }
}

impl UnknownMessage {
    pub fn new() -> UnknownMessage {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnknownMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnknownMessage {
        UnknownMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnknownMessage>(
                "UnknownMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnknownMessage {
        static instance: ::protobuf::rt::LazyV2<UnknownMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnknownMessage::new)
    }
}

impl ::protobuf::Clear for UnknownMessage {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnknownMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnknownMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerUpdate {
    // message fields
    pub tag1: i64,
    pub tag2: i32,
    pub tag3: i32,
    pub payload: ::std::vec::Vec<u8>,
    pub tag5: i64,
    pub tag6: i64,
    pub tag7: i64,
    pub tag8: i64,
    pub tag9: i64,
    pub tag11: i64,
    pub tag12: i64,
    pub tag14: i64,
    pub tag15: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerUpdate {
    fn default() -> &'a PlayerUpdate {
        <PlayerUpdate as ::protobuf::Message>::default_instance()
    }
}

impl PlayerUpdate {
    pub fn new() -> PlayerUpdate {
        ::std::default::Default::default()
    }

    // int64 tag1 = 1;


    pub fn get_tag1(&self) -> i64 {
        self.tag1
    }
    pub fn clear_tag1(&mut self) {
        self.tag1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag1(&mut self, v: i64) {
        self.tag1 = v;
    }

    // int32 tag2 = 2;


    pub fn get_tag2(&self) -> i32 {
        self.tag2
    }
    pub fn clear_tag2(&mut self) {
        self.tag2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag2(&mut self, v: i32) {
        self.tag2 = v;
    }

    // int32 tag3 = 3;


    pub fn get_tag3(&self) -> i32 {
        self.tag3
    }
    pub fn clear_tag3(&mut self) {
        self.tag3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag3(&mut self, v: i32) {
        self.tag3 = v;
    }

    // bytes payload = 4;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // int64 tag5 = 5;


    pub fn get_tag5(&self) -> i64 {
        self.tag5
    }
    pub fn clear_tag5(&mut self) {
        self.tag5 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag5(&mut self, v: i64) {
        self.tag5 = v;
    }

    // int64 tag6 = 6;


    pub fn get_tag6(&self) -> i64 {
        self.tag6
    }
    pub fn clear_tag6(&mut self) {
        self.tag6 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag6(&mut self, v: i64) {
        self.tag6 = v;
    }

    // int64 tag7 = 7;


    pub fn get_tag7(&self) -> i64 {
        self.tag7
    }
    pub fn clear_tag7(&mut self) {
        self.tag7 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag7(&mut self, v: i64) {
        self.tag7 = v;
    }

    // int64 tag8 = 8;


    pub fn get_tag8(&self) -> i64 {
        self.tag8
    }
    pub fn clear_tag8(&mut self) {
        self.tag8 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag8(&mut self, v: i64) {
        self.tag8 = v;
    }

    // int64 tag9 = 9;


    pub fn get_tag9(&self) -> i64 {
        self.tag9
    }
    pub fn clear_tag9(&mut self) {
        self.tag9 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag9(&mut self, v: i64) {
        self.tag9 = v;
    }

    // int64 tag11 = 11;


    pub fn get_tag11(&self) -> i64 {
        self.tag11
    }
    pub fn clear_tag11(&mut self) {
        self.tag11 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag11(&mut self, v: i64) {
        self.tag11 = v;
    }

    // int64 tag12 = 12;


    pub fn get_tag12(&self) -> i64 {
        self.tag12
    }
    pub fn clear_tag12(&mut self) {
        self.tag12 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag12(&mut self, v: i64) {
        self.tag12 = v;
    }

    // int64 tag14 = 14;


    pub fn get_tag14(&self) -> i64 {
        self.tag14
    }
    pub fn clear_tag14(&mut self) {
        self.tag14 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag14(&mut self, v: i64) {
        self.tag14 = v;
    }

    // int64 tag15 = 15;


    pub fn get_tag15(&self) -> i64 {
        self.tag15
    }
    pub fn clear_tag15(&mut self) {
        self.tag15 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag15(&mut self, v: i64) {
        self.tag15 = v;
    }
}

impl ::protobuf::Message for PlayerUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tag2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tag3 = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag5 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag6 = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag7 = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag8 = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag9 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag11 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag12 = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag14 = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag15 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tag1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tag2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.tag3, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payload);
        }
        if self.tag5 != 0 {
            my_size += ::protobuf::rt::value_size(5, self.tag5, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag6 != 0 {
            my_size += ::protobuf::rt::value_size(6, self.tag6, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag7 != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tag7, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag8 != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tag8, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag9 != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tag9, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag11 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.tag11, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag12 != 0 {
            my_size += ::protobuf::rt::value_size(12, self.tag12, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag14 != 0 {
            my_size += ::protobuf::rt::value_size(14, self.tag14, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag15 != 0 {
            my_size += ::protobuf::rt::value_size(15, self.tag15, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tag1 != 0 {
            os.write_int64(1, self.tag1)?;
        }
        if self.tag2 != 0 {
            os.write_int32(2, self.tag2)?;
        }
        if self.tag3 != 0 {
            os.write_int32(3, self.tag3)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(4, &self.payload)?;
        }
        if self.tag5 != 0 {
            os.write_int64(5, self.tag5)?;
        }
        if self.tag6 != 0 {
            os.write_int64(6, self.tag6)?;
        }
        if self.tag7 != 0 {
            os.write_int64(7, self.tag7)?;
        }
        if self.tag8 != 0 {
            os.write_int64(8, self.tag8)?;
        }
        if self.tag9 != 0 {
            os.write_int64(9, self.tag9)?;
        }
        if self.tag11 != 0 {
            os.write_int64(11, self.tag11)?;
        }
        if self.tag12 != 0 {
            os.write_int64(12, self.tag12)?;
        }
        if self.tag14 != 0 {
            os.write_int64(14, self.tag14)?;
        }
        if self.tag15 != 0 {
            os.write_int64(15, self.tag15)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerUpdate {
        PlayerUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag1",
                |m: &PlayerUpdate| { &m.tag1 },
                |m: &mut PlayerUpdate| { &mut m.tag1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tag2",
                |m: &PlayerUpdate| { &m.tag2 },
                |m: &mut PlayerUpdate| { &mut m.tag2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tag3",
                |m: &PlayerUpdate| { &m.tag3 },
                |m: &mut PlayerUpdate| { &mut m.tag3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &PlayerUpdate| { &m.payload },
                |m: &mut PlayerUpdate| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag5",
                |m: &PlayerUpdate| { &m.tag5 },
                |m: &mut PlayerUpdate| { &mut m.tag5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag6",
                |m: &PlayerUpdate| { &m.tag6 },
                |m: &mut PlayerUpdate| { &mut m.tag6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag7",
                |m: &PlayerUpdate| { &m.tag7 },
                |m: &mut PlayerUpdate| { &mut m.tag7 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag8",
                |m: &PlayerUpdate| { &m.tag8 },
                |m: &mut PlayerUpdate| { &mut m.tag8 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag9",
                |m: &PlayerUpdate| { &m.tag9 },
                |m: &mut PlayerUpdate| { &mut m.tag9 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag11",
                |m: &PlayerUpdate| { &m.tag11 },
                |m: &mut PlayerUpdate| { &mut m.tag11 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag12",
                |m: &PlayerUpdate| { &m.tag12 },
                |m: &mut PlayerUpdate| { &mut m.tag12 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag14",
                |m: &PlayerUpdate| { &m.tag14 },
                |m: &mut PlayerUpdate| { &mut m.tag14 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag15",
                |m: &PlayerUpdate| { &m.tag15 },
                |m: &mut PlayerUpdate| { &mut m.tag15 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerUpdate>(
                "PlayerUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerUpdate {
        static instance: ::protobuf::rt::LazyV2<PlayerUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerUpdate::new)
    }
}

impl ::protobuf::Clear for PlayerUpdate {
    fn clear(&mut self) {
        self.tag1 = 0;
        self.tag2 = 0;
        self.tag3 = 0;
        self.payload.clear();
        self.tag5 = 0;
        self.tag6 = 0;
        self.tag7 = 0;
        self.tag8 = 0;
        self.tag9 = 0;
        self.tag11 = 0;
        self.tag12 = 0;
        self.tag14 = 0;
        self.tag15 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload105 {
    // message fields
    pub f1: i64,
    pub rider_id: i32,
    pub f3: i32,
    pub f4: i64,
    pub f5: i64,
    pub f6: i64,
    pub firstName: ::std::string::String,
    pub lastName: ::std::string::String,
    pub f9: i64,
    pub f11: i64,
    pub f12: i32,
    pub f13: i32,
    pub f14: i32,
    pub f15: i32,
    pub f16: i32,
    pub f7date: ::std::string::String,
    pub f19: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload105 {
    fn default() -> &'a Payload105 {
        <Payload105 as ::protobuf::Message>::default_instance()
    }
}

impl Payload105 {
    pub fn new() -> Payload105 {
        ::std::default::Default::default()
    }

    // int64 f1 = 1;


    pub fn get_f1(&self) -> i64 {
        self.f1
    }
    pub fn clear_f1(&mut self) {
        self.f1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: i64) {
        self.f1 = v;
    }

    // int32 rider_id = 2;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = v;
    }

    // int32 f3 = 3;


    pub fn get_f3(&self) -> i32 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: i32) {
        self.f3 = v;
    }

    // int64 f4 = 4;


    pub fn get_f4(&self) -> i64 {
        self.f4
    }
    pub fn clear_f4(&mut self) {
        self.f4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f4(&mut self, v: i64) {
        self.f4 = v;
    }

    // int64 f5 = 5;


    pub fn get_f5(&self) -> i64 {
        self.f5
    }
    pub fn clear_f5(&mut self) {
        self.f5 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f5(&mut self, v: i64) {
        self.f5 = v;
    }

    // int64 f6 = 6;


    pub fn get_f6(&self) -> i64 {
        self.f6
    }
    pub fn clear_f6(&mut self) {
        self.f6 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f6(&mut self, v: i64) {
        self.f6 = v;
    }

    // string firstName = 7;


    pub fn get_firstName(&self) -> &str {
        &self.firstName
    }
    pub fn clear_firstName(&mut self) {
        self.firstName.clear();
    }

    // Param is passed by value, moved
    pub fn set_firstName(&mut self, v: ::std::string::String) {
        self.firstName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstName(&mut self) -> &mut ::std::string::String {
        &mut self.firstName
    }

    // Take field
    pub fn take_firstName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.firstName, ::std::string::String::new())
    }

    // string lastName = 8;


    pub fn get_lastName(&self) -> &str {
        &self.lastName
    }
    pub fn clear_lastName(&mut self) {
        self.lastName.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastName(&mut self, v: ::std::string::String) {
        self.lastName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastName(&mut self) -> &mut ::std::string::String {
        &mut self.lastName
    }

    // Take field
    pub fn take_lastName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastName, ::std::string::String::new())
    }

    // int64 f9 = 9;


    pub fn get_f9(&self) -> i64 {
        self.f9
    }
    pub fn clear_f9(&mut self) {
        self.f9 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f9(&mut self, v: i64) {
        self.f9 = v;
    }

    // int64 f11 = 11;


    pub fn get_f11(&self) -> i64 {
        self.f11
    }
    pub fn clear_f11(&mut self) {
        self.f11 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f11(&mut self, v: i64) {
        self.f11 = v;
    }

    // int32 f12 = 12;


    pub fn get_f12(&self) -> i32 {
        self.f12
    }
    pub fn clear_f12(&mut self) {
        self.f12 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f12(&mut self, v: i32) {
        self.f12 = v;
    }

    // int32 f13 = 13;


    pub fn get_f13(&self) -> i32 {
        self.f13
    }
    pub fn clear_f13(&mut self) {
        self.f13 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f13(&mut self, v: i32) {
        self.f13 = v;
    }

    // int32 f14 = 14;


    pub fn get_f14(&self) -> i32 {
        self.f14
    }
    pub fn clear_f14(&mut self) {
        self.f14 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f14(&mut self, v: i32) {
        self.f14 = v;
    }

    // int32 f15 = 15;


    pub fn get_f15(&self) -> i32 {
        self.f15
    }
    pub fn clear_f15(&mut self) {
        self.f15 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f15(&mut self, v: i32) {
        self.f15 = v;
    }

    // int32 f16 = 16;


    pub fn get_f16(&self) -> i32 {
        self.f16
    }
    pub fn clear_f16(&mut self) {
        self.f16 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f16(&mut self, v: i32) {
        self.f16 = v;
    }

    // string f7date = 17;


    pub fn get_f7date(&self) -> &str {
        &self.f7date
    }
    pub fn clear_f7date(&mut self) {
        self.f7date.clear();
    }

    // Param is passed by value, moved
    pub fn set_f7date(&mut self, v: ::std::string::String) {
        self.f7date = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_f7date(&mut self) -> &mut ::std::string::String {
        &mut self.f7date
    }

    // Take field
    pub fn take_f7date(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.f7date, ::std::string::String::new())
    }

    // int32 f19 = 19;


    pub fn get_f19(&self) -> i32 {
        self.f19
    }
    pub fn clear_f19(&mut self) {
        self.f19 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f19(&mut self, v: i32) {
        self.f19 = v;
    }
}

impl ::protobuf::Message for Payload105 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f3 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f4 = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f5 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f6 = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.firstName)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastName)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f9 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f11 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f12 = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f13 = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f14 = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f15 = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f16 = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.f7date)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f19 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.f1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.f1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rider_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f4 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.f4, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f5 != 0 {
            my_size += ::protobuf::rt::value_size(5, self.f5, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f6 != 0 {
            my_size += ::protobuf::rt::value_size(6, self.f6, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.firstName.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.firstName);
        }
        if !self.lastName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.lastName);
        }
        if self.f9 != 0 {
            my_size += ::protobuf::rt::value_size(9, self.f9, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f11 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.f11, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f12 != 0 {
            my_size += ::protobuf::rt::value_size(12, self.f12, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f13 != 0 {
            my_size += ::protobuf::rt::value_size(13, self.f13, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f14 != 0 {
            my_size += ::protobuf::rt::value_size(14, self.f14, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f15 != 0 {
            my_size += ::protobuf::rt::value_size(15, self.f15, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f16 != 0 {
            my_size += ::protobuf::rt::value_size(16, self.f16, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.f7date.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.f7date);
        }
        if self.f19 != 0 {
            my_size += ::protobuf::rt::value_size(19, self.f19, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.f1 != 0 {
            os.write_int64(1, self.f1)?;
        }
        if self.rider_id != 0 {
            os.write_int32(2, self.rider_id)?;
        }
        if self.f3 != 0 {
            os.write_int32(3, self.f3)?;
        }
        if self.f4 != 0 {
            os.write_int64(4, self.f4)?;
        }
        if self.f5 != 0 {
            os.write_int64(5, self.f5)?;
        }
        if self.f6 != 0 {
            os.write_int64(6, self.f6)?;
        }
        if !self.firstName.is_empty() {
            os.write_string(7, &self.firstName)?;
        }
        if !self.lastName.is_empty() {
            os.write_string(8, &self.lastName)?;
        }
        if self.f9 != 0 {
            os.write_int64(9, self.f9)?;
        }
        if self.f11 != 0 {
            os.write_int64(11, self.f11)?;
        }
        if self.f12 != 0 {
            os.write_int32(12, self.f12)?;
        }
        if self.f13 != 0 {
            os.write_int32(13, self.f13)?;
        }
        if self.f14 != 0 {
            os.write_int32(14, self.f14)?;
        }
        if self.f15 != 0 {
            os.write_int32(15, self.f15)?;
        }
        if self.f16 != 0 {
            os.write_int32(16, self.f16)?;
        }
        if !self.f7date.is_empty() {
            os.write_string(17, &self.f7date)?;
        }
        if self.f19 != 0 {
            os.write_int32(19, self.f19)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload105 {
        Payload105::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f1",
                |m: &Payload105| { &m.f1 },
                |m: &mut Payload105| { &mut m.f1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &Payload105| { &m.rider_id },
                |m: &mut Payload105| { &mut m.rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f3",
                |m: &Payload105| { &m.f3 },
                |m: &mut Payload105| { &mut m.f3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f4",
                |m: &Payload105| { &m.f4 },
                |m: &mut Payload105| { &mut m.f4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f5",
                |m: &Payload105| { &m.f5 },
                |m: &mut Payload105| { &mut m.f5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f6",
                |m: &Payload105| { &m.f6 },
                |m: &mut Payload105| { &mut m.f6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstName",
                |m: &Payload105| { &m.firstName },
                |m: &mut Payload105| { &mut m.firstName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastName",
                |m: &Payload105| { &m.lastName },
                |m: &mut Payload105| { &mut m.lastName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f9",
                |m: &Payload105| { &m.f9 },
                |m: &mut Payload105| { &mut m.f9 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f11",
                |m: &Payload105| { &m.f11 },
                |m: &mut Payload105| { &mut m.f11 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f12",
                |m: &Payload105| { &m.f12 },
                |m: &mut Payload105| { &mut m.f12 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f13",
                |m: &Payload105| { &m.f13 },
                |m: &mut Payload105| { &mut m.f13 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f14",
                |m: &Payload105| { &m.f14 },
                |m: &mut Payload105| { &mut m.f14 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f15",
                |m: &Payload105| { &m.f15 },
                |m: &mut Payload105| { &mut m.f15 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f16",
                |m: &Payload105| { &m.f16 },
                |m: &mut Payload105| { &mut m.f16 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "f7date",
                |m: &Payload105| { &m.f7date },
                |m: &mut Payload105| { &mut m.f7date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f19",
                |m: &Payload105| { &m.f19 },
                |m: &mut Payload105| { &mut m.f19 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload105>(
                "Payload105",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload105 {
        static instance: ::protobuf::rt::LazyV2<Payload105> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload105::new)
    }
}

impl ::protobuf::Clear for Payload105 {
    fn clear(&mut self) {
        self.f1 = 0;
        self.rider_id = 0;
        self.f3 = 0;
        self.f4 = 0;
        self.f5 = 0;
        self.f6 = 0;
        self.firstName.clear();
        self.lastName.clear();
        self.f9 = 0;
        self.f11 = 0;
        self.f12 = 0;
        self.f13 = 0;
        self.f14 = 0;
        self.f15 = 0;
        self.f16 = 0;
        self.f7date.clear();
        self.f19 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload105 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload105 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Chat {
    // message fields
    pub rider_id: i32,
    pub to_rider_id: i32,
    pub f3: i32,
    pub firstName: ::std::string::String,
    pub lastName: ::std::string::String,
    pub message: ::std::string::String,
    pub avatar: ::std::string::String,
    pub countryCode: i32,
    pub eventSubgroup: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Chat {
    fn default() -> &'a Chat {
        <Chat as ::protobuf::Message>::default_instance()
    }
}

impl Chat {
    pub fn new() -> Chat {
        ::std::default::Default::default()
    }

    // int32 rider_id = 1;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = v;
    }

    // int32 to_rider_id = 2;


    pub fn get_to_rider_id(&self) -> i32 {
        self.to_rider_id
    }
    pub fn clear_to_rider_id(&mut self) {
        self.to_rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_rider_id(&mut self, v: i32) {
        self.to_rider_id = v;
    }

    // int32 f3 = 3;


    pub fn get_f3(&self) -> i32 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: i32) {
        self.f3 = v;
    }

    // string firstName = 4;


    pub fn get_firstName(&self) -> &str {
        &self.firstName
    }
    pub fn clear_firstName(&mut self) {
        self.firstName.clear();
    }

    // Param is passed by value, moved
    pub fn set_firstName(&mut self, v: ::std::string::String) {
        self.firstName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstName(&mut self) -> &mut ::std::string::String {
        &mut self.firstName
    }

    // Take field
    pub fn take_firstName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.firstName, ::std::string::String::new())
    }

    // string lastName = 5;


    pub fn get_lastName(&self) -> &str {
        &self.lastName
    }
    pub fn clear_lastName(&mut self) {
        self.lastName.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastName(&mut self, v: ::std::string::String) {
        self.lastName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastName(&mut self) -> &mut ::std::string::String {
        &mut self.lastName
    }

    // Take field
    pub fn take_lastName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastName, ::std::string::String::new())
    }

    // string message = 6;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string avatar = 7;


    pub fn get_avatar(&self) -> &str {
        &self.avatar
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ::std::string::String) {
        self.avatar = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut ::std::string::String {
        &mut self.avatar
    }

    // Take field
    pub fn take_avatar(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.avatar, ::std::string::String::new())
    }

    // int32 countryCode = 8;


    pub fn get_countryCode(&self) -> i32 {
        self.countryCode
    }
    pub fn clear_countryCode(&mut self) {
        self.countryCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_countryCode(&mut self, v: i32) {
        self.countryCode = v;
    }

    // int32 eventSubgroup = 11;


    pub fn get_eventSubgroup(&self) -> i32 {
        self.eventSubgroup
    }
    pub fn clear_eventSubgroup(&mut self) {
        self.eventSubgroup = 0;
    }

    // Param is passed by value, moved
    pub fn set_eventSubgroup(&mut self, v: i32) {
        self.eventSubgroup = v;
    }
}

impl ::protobuf::Message for Chat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.to_rider_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f3 = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.firstName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.avatar)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.countryCode = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eventSubgroup = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rider_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.to_rider_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.to_rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.firstName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.firstName);
        }
        if !self.lastName.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.lastName);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.message);
        }
        if !self.avatar.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.avatar);
        }
        if self.countryCode != 0 {
            my_size += ::protobuf::rt::value_size(8, self.countryCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.eventSubgroup != 0 {
            my_size += ::protobuf::rt::value_size(11, self.eventSubgroup, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rider_id != 0 {
            os.write_int32(1, self.rider_id)?;
        }
        if self.to_rider_id != 0 {
            os.write_int32(2, self.to_rider_id)?;
        }
        if self.f3 != 0 {
            os.write_int32(3, self.f3)?;
        }
        if !self.firstName.is_empty() {
            os.write_string(4, &self.firstName)?;
        }
        if !self.lastName.is_empty() {
            os.write_string(5, &self.lastName)?;
        }
        if !self.message.is_empty() {
            os.write_string(6, &self.message)?;
        }
        if !self.avatar.is_empty() {
            os.write_string(7, &self.avatar)?;
        }
        if self.countryCode != 0 {
            os.write_int32(8, self.countryCode)?;
        }
        if self.eventSubgroup != 0 {
            os.write_int32(11, self.eventSubgroup)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Chat {
        Chat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &Chat| { &m.rider_id },
                |m: &mut Chat| { &mut m.rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "to_rider_id",
                |m: &Chat| { &m.to_rider_id },
                |m: &mut Chat| { &mut m.to_rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f3",
                |m: &Chat| { &m.f3 },
                |m: &mut Chat| { &mut m.f3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstName",
                |m: &Chat| { &m.firstName },
                |m: &mut Chat| { &mut m.firstName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastName",
                |m: &Chat| { &m.lastName },
                |m: &mut Chat| { &mut m.lastName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Chat| { &m.message },
                |m: &mut Chat| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "avatar",
                |m: &Chat| { &m.avatar },
                |m: &mut Chat| { &mut m.avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "countryCode",
                |m: &Chat| { &m.countryCode },
                |m: &mut Chat| { &mut m.countryCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eventSubgroup",
                |m: &Chat| { &m.eventSubgroup },
                |m: &mut Chat| { &mut m.eventSubgroup },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Chat>(
                "Chat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Chat {
        static instance: ::protobuf::rt::LazyV2<Chat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Chat::new)
    }
}

impl ::protobuf::Clear for Chat {
    fn clear(&mut self) {
        self.rider_id = 0;
        self.to_rider_id = 0;
        self.f3 = 0;
        self.firstName.clear();
        self.lastName.clear();
        self.message.clear();
        self.avatar.clear();
        self.countryCode = 0;
        self.eventSubgroup = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Chat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RideOn {
    // message fields
    pub rider_id: i32,
    pub to_rider_id: i32,
    pub firstName: ::std::string::String,
    pub lastName: ::std::string::String,
    pub countryCode: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RideOn {
    fn default() -> &'a RideOn {
        <RideOn as ::protobuf::Message>::default_instance()
    }
}

impl RideOn {
    pub fn new() -> RideOn {
        ::std::default::Default::default()
    }

    // int32 rider_id = 1;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = v;
    }

    // int32 to_rider_id = 2;


    pub fn get_to_rider_id(&self) -> i32 {
        self.to_rider_id
    }
    pub fn clear_to_rider_id(&mut self) {
        self.to_rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_rider_id(&mut self, v: i32) {
        self.to_rider_id = v;
    }

    // string firstName = 3;


    pub fn get_firstName(&self) -> &str {
        &self.firstName
    }
    pub fn clear_firstName(&mut self) {
        self.firstName.clear();
    }

    // Param is passed by value, moved
    pub fn set_firstName(&mut self, v: ::std::string::String) {
        self.firstName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstName(&mut self) -> &mut ::std::string::String {
        &mut self.firstName
    }

    // Take field
    pub fn take_firstName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.firstName, ::std::string::String::new())
    }

    // string lastName = 4;


    pub fn get_lastName(&self) -> &str {
        &self.lastName
    }
    pub fn clear_lastName(&mut self) {
        self.lastName.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastName(&mut self, v: ::std::string::String) {
        self.lastName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastName(&mut self) -> &mut ::std::string::String {
        &mut self.lastName
    }

    // Take field
    pub fn take_lastName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastName, ::std::string::String::new())
    }

    // int32 countryCode = 5;


    pub fn get_countryCode(&self) -> i32 {
        self.countryCode
    }
    pub fn clear_countryCode(&mut self) {
        self.countryCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_countryCode(&mut self, v: i32) {
        self.countryCode = v;
    }
}

impl ::protobuf::Message for RideOn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.to_rider_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.firstName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastName)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.countryCode = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rider_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.to_rider_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.to_rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.firstName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.firstName);
        }
        if !self.lastName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.lastName);
        }
        if self.countryCode != 0 {
            my_size += ::protobuf::rt::value_size(5, self.countryCode, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rider_id != 0 {
            os.write_int32(1, self.rider_id)?;
        }
        if self.to_rider_id != 0 {
            os.write_int32(2, self.to_rider_id)?;
        }
        if !self.firstName.is_empty() {
            os.write_string(3, &self.firstName)?;
        }
        if !self.lastName.is_empty() {
            os.write_string(4, &self.lastName)?;
        }
        if self.countryCode != 0 {
            os.write_int32(5, self.countryCode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RideOn {
        RideOn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &RideOn| { &m.rider_id },
                |m: &mut RideOn| { &mut m.rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "to_rider_id",
                |m: &RideOn| { &m.to_rider_id },
                |m: &mut RideOn| { &mut m.to_rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstName",
                |m: &RideOn| { &m.firstName },
                |m: &mut RideOn| { &mut m.firstName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastName",
                |m: &RideOn| { &m.lastName },
                |m: &mut RideOn| { &mut m.lastName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "countryCode",
                |m: &RideOn| { &m.countryCode },
                |m: &mut RideOn| { &mut m.countryCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RideOn>(
                "RideOn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RideOn {
        static instance: ::protobuf::rt::LazyV2<RideOn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RideOn::new)
    }
}

impl ::protobuf::Clear for RideOn {
    fn clear(&mut self) {
        self.rider_id = 0;
        self.to_rider_id = 0;
        self.firstName.clear();
        self.lastName.clear();
        self.countryCode = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RideOn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RideOn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload2 {
    // message fields
    pub f1: i32,
    pub f2: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload2 {
    fn default() -> &'a Payload2 {
        <Payload2 as ::protobuf::Message>::default_instance()
    }
}

impl Payload2 {
    pub fn new() -> Payload2 {
        ::std::default::Default::default()
    }

    // int32 f1 = 1;


    pub fn get_f1(&self) -> i32 {
        self.f1
    }
    pub fn clear_f1(&mut self) {
        self.f1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: i32) {
        self.f1 = v;
    }

    // int64 f2 = 2;


    pub fn get_f2(&self) -> i64 {
        self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: i64) {
        self.f2 = v;
    }
}

impl ::protobuf::Message for Payload2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.f2 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.f1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.f1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f2, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.f1 != 0 {
            os.write_int32(1, self.f1)?;
        }
        if self.f2 != 0 {
            os.write_int64(2, self.f2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload2 {
        Payload2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f1",
                |m: &Payload2| { &m.f1 },
                |m: &mut Payload2| { &mut m.f1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "f2",
                |m: &Payload2| { &m.f2 },
                |m: &mut Payload2| { &mut m.f2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload2>(
                "Payload2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload2 {
        static instance: ::protobuf::rt::LazyV2<Payload2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload2::new)
    }
}

impl ::protobuf::Clear for Payload2 {
    fn clear(&mut self) {
        self.f1 = 0;
        self.f2 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeSync {
    // message fields
    pub rider_id: i32,
    pub world_time: i64,
    pub f3: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeSync {
    fn default() -> &'a TimeSync {
        <TimeSync as ::protobuf::Message>::default_instance()
    }
}

impl TimeSync {
    pub fn new() -> TimeSync {
        ::std::default::Default::default()
    }

    // int32 rider_id = 1;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = v;
    }

    // int64 world_time = 2;


    pub fn get_world_time(&self) -> i64 {
        self.world_time
    }
    pub fn clear_world_time(&mut self) {
        self.world_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_world_time(&mut self, v: i64) {
        self.world_time = v;
    }

    // int32 f3 = 3;


    pub fn get_f3(&self) -> i32 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: i32) {
        self.f3 = v;
    }
}

impl ::protobuf::Message for TimeSync {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.world_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f3 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rider_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.world_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.world_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rider_id != 0 {
            os.write_int32(1, self.rider_id)?;
        }
        if self.world_time != 0 {
            os.write_int64(2, self.world_time)?;
        }
        if self.f3 != 0 {
            os.write_int32(3, self.f3)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeSync {
        TimeSync::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &TimeSync| { &m.rider_id },
                |m: &mut TimeSync| { &mut m.rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "world_time",
                |m: &TimeSync| { &m.world_time },
                |m: &mut TimeSync| { &mut m.world_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f3",
                |m: &TimeSync| { &m.f3 },
                |m: &mut TimeSync| { &mut m.f3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeSync>(
                "TimeSync",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeSync {
        static instance: ::protobuf::rt::LazyV2<TimeSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeSync::new)
    }
}

impl ::protobuf::Clear for TimeSync {
    fn clear(&mut self) {
        self.rider_id = 0;
        self.world_time = 0;
        self.f3 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload110 {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload110 {
    fn default() -> &'a Payload110 {
        <Payload110 as ::protobuf::Message>::default_instance()
    }
}

impl Payload110 {
    pub fn new() -> Payload110 {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Payload110 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload110 {
        Payload110::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload110>(
                "Payload110",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload110 {
        static instance: ::protobuf::rt::LazyV2<Payload110> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload110::new)
    }
}

impl ::protobuf::Clear for Payload110 {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload110 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload110 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload109 {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload109 {
    fn default() -> &'a Payload109 {
        <Payload109 as ::protobuf::Message>::default_instance()
    }
}

impl Payload109 {
    pub fn new() -> Payload109 {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Payload109 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload109 {
        Payload109::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload109>(
                "Payload109",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload109 {
        static instance: ::protobuf::rt::LazyV2<Payload109> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload109::new)
    }
}

impl ::protobuf::Clear for Payload109 {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload109 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload109 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventPositions {
    // message fields
    pub position: i32,
    pub eventRiderPosition: ::protobuf::RepeatedField<EventPositions_EventRiderPosition>,
    pub num_riders: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventPositions {
    fn default() -> &'a EventPositions {
        <EventPositions as ::protobuf::Message>::default_instance()
    }
}

impl EventPositions {
    pub fn new() -> EventPositions {
        ::std::default::Default::default()
    }

    // int32 position = 1;


    pub fn get_position(&self) -> i32 {
        self.position
    }
    pub fn clear_position(&mut self) {
        self.position = 0;
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: i32) {
        self.position = v;
    }

    // repeated .ZwiftPacketMonitor.EventPositions.EventRiderPosition eventRiderPosition = 4;


    pub fn get_eventRiderPosition(&self) -> &[EventPositions_EventRiderPosition] {
        &self.eventRiderPosition
    }
    pub fn clear_eventRiderPosition(&mut self) {
        self.eventRiderPosition.clear();
    }

    // Param is passed by value, moved
    pub fn set_eventRiderPosition(&mut self, v: ::protobuf::RepeatedField<EventPositions_EventRiderPosition>) {
        self.eventRiderPosition = v;
    }

    // Mutable pointer to the field.
    pub fn mut_eventRiderPosition(&mut self) -> &mut ::protobuf::RepeatedField<EventPositions_EventRiderPosition> {
        &mut self.eventRiderPosition
    }

    // Take field
    pub fn take_eventRiderPosition(&mut self) -> ::protobuf::RepeatedField<EventPositions_EventRiderPosition> {
        ::std::mem::replace(&mut self.eventRiderPosition, ::protobuf::RepeatedField::new())
    }

    // int32 num_riders = 116;


    pub fn get_num_riders(&self) -> i32 {
        self.num_riders
    }
    pub fn clear_num_riders(&mut self) {
        self.num_riders = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_riders(&mut self, v: i32) {
        self.num_riders = v;
    }
}

impl ::protobuf::Message for EventPositions {
    fn is_initialized(&self) -> bool {
        for v in &self.eventRiderPosition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.position = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.eventRiderPosition)?;
                },
                116 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_riders = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.position != 0 {
            my_size += ::protobuf::rt::value_size(1, self.position, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.eventRiderPosition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.num_riders != 0 {
            my_size += ::protobuf::rt::value_size(116, self.num_riders, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.position != 0 {
            os.write_int32(1, self.position)?;
        }
        for v in &self.eventRiderPosition {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.num_riders != 0 {
            os.write_int32(116, self.num_riders)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventPositions {
        EventPositions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "position",
                |m: &EventPositions| { &m.position },
                |m: &mut EventPositions| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventPositions_EventRiderPosition>>(
                "eventRiderPosition",
                |m: &EventPositions| { &m.eventRiderPosition },
                |m: &mut EventPositions| { &mut m.eventRiderPosition },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_riders",
                |m: &EventPositions| { &m.num_riders },
                |m: &mut EventPositions| { &mut m.num_riders },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventPositions>(
                "EventPositions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventPositions {
        static instance: ::protobuf::rt::LazyV2<EventPositions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventPositions::new)
    }
}

impl ::protobuf::Clear for EventPositions {
    fn clear(&mut self) {
        self.position = 0;
        self.eventRiderPosition.clear();
        self.num_riders = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventPositions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventPositions_EventRiderPosition {
    // message fields
    pub rider_id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventPositions_EventRiderPosition {
    fn default() -> &'a EventPositions_EventRiderPosition {
        <EventPositions_EventRiderPosition as ::protobuf::Message>::default_instance()
    }
}

impl EventPositions_EventRiderPosition {
    pub fn new() -> EventPositions_EventRiderPosition {
        ::std::default::Default::default()
    }

    // int32 rider_id = 1;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = v;
    }
}

impl ::protobuf::Message for EventPositions_EventRiderPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rider_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rider_id != 0 {
            os.write_int32(1, self.rider_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventPositions_EventRiderPosition {
        EventPositions_EventRiderPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &EventPositions_EventRiderPosition| { &m.rider_id },
                |m: &mut EventPositions_EventRiderPosition| { &mut m.rider_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventPositions_EventRiderPosition>(
                "EventPositions.EventRiderPosition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventPositions_EventRiderPosition {
        static instance: ::protobuf::rt::LazyV2<EventPositions_EventRiderPosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventPositions_EventRiderPosition::new)
    }
}

impl ::protobuf::Clear for EventPositions_EventRiderPosition {
    fn clear(&mut self) {
        self.rider_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventPositions_EventRiderPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventPositions_EventRiderPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerToClient {
    // message fields
    pub tag1: i32,
    pub rider_id: i32,
    pub world_time: i64,
    pub seqno: i32,
    pub player_states: ::protobuf::RepeatedField<PlayerState>,
    pub player_updates: ::protobuf::RepeatedField<PlayerUpdate>,
    pub tag11: i64,
    pub local_ip: ::std::string::String,
    pub tag15: i32,
    pub tag17: i64,
    pub num_msgs: i32,
    pub msgnum: i32,
    pub event_positions: ::protobuf::SingularPtrField<EventPositions>,
    pub servers1: ::protobuf::SingularPtrField<Server1>,
    pub servers2: ::protobuf::SingularPtrField<Server2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerToClient {
    fn default() -> &'a ServerToClient {
        <ServerToClient as ::protobuf::Message>::default_instance()
    }
}

impl ServerToClient {
    pub fn new() -> ServerToClient {
        ::std::default::Default::default()
    }

    // int32 tag1 = 1;


    pub fn get_tag1(&self) -> i32 {
        self.tag1
    }
    pub fn clear_tag1(&mut self) {
        self.tag1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag1(&mut self, v: i32) {
        self.tag1 = v;
    }

    // int32 rider_id = 2;


    pub fn get_rider_id(&self) -> i32 {
        self.rider_id
    }
    pub fn clear_rider_id(&mut self) {
        self.rider_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_rider_id(&mut self, v: i32) {
        self.rider_id = v;
    }

    // int64 world_time = 3;


    pub fn get_world_time(&self) -> i64 {
        self.world_time
    }
    pub fn clear_world_time(&mut self) {
        self.world_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_world_time(&mut self, v: i64) {
        self.world_time = v;
    }

    // int32 seqno = 4;


    pub fn get_seqno(&self) -> i32 {
        self.seqno
    }
    pub fn clear_seqno(&mut self) {
        self.seqno = 0;
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i32) {
        self.seqno = v;
    }

    // repeated .ZwiftPacketMonitor.PlayerState player_states = 8;


    pub fn get_player_states(&self) -> &[PlayerState] {
        &self.player_states
    }
    pub fn clear_player_states(&mut self) {
        self.player_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_states(&mut self, v: ::protobuf::RepeatedField<PlayerState>) {
        self.player_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_states(&mut self) -> &mut ::protobuf::RepeatedField<PlayerState> {
        &mut self.player_states
    }

    // Take field
    pub fn take_player_states(&mut self) -> ::protobuf::RepeatedField<PlayerState> {
        ::std::mem::replace(&mut self.player_states, ::protobuf::RepeatedField::new())
    }

    // repeated .ZwiftPacketMonitor.PlayerUpdate player_updates = 9;


    pub fn get_player_updates(&self) -> &[PlayerUpdate] {
        &self.player_updates
    }
    pub fn clear_player_updates(&mut self) {
        self.player_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_updates(&mut self, v: ::protobuf::RepeatedField<PlayerUpdate>) {
        self.player_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_updates(&mut self) -> &mut ::protobuf::RepeatedField<PlayerUpdate> {
        &mut self.player_updates
    }

    // Take field
    pub fn take_player_updates(&mut self) -> ::protobuf::RepeatedField<PlayerUpdate> {
        ::std::mem::replace(&mut self.player_updates, ::protobuf::RepeatedField::new())
    }

    // int64 tag11 = 11;


    pub fn get_tag11(&self) -> i64 {
        self.tag11
    }
    pub fn clear_tag11(&mut self) {
        self.tag11 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag11(&mut self, v: i64) {
        self.tag11 = v;
    }

    // string local_ip = 12;


    pub fn get_local_ip(&self) -> &str {
        &self.local_ip
    }
    pub fn clear_local_ip(&mut self) {
        self.local_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_ip(&mut self, v: ::std::string::String) {
        self.local_ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_ip(&mut self) -> &mut ::std::string::String {
        &mut self.local_ip
    }

    // Take field
    pub fn take_local_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_ip, ::std::string::String::new())
    }

    // int32 tag15 = 15;


    pub fn get_tag15(&self) -> i32 {
        self.tag15
    }
    pub fn clear_tag15(&mut self) {
        self.tag15 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag15(&mut self, v: i32) {
        self.tag15 = v;
    }

    // int64 tag17 = 17;


    pub fn get_tag17(&self) -> i64 {
        self.tag17
    }
    pub fn clear_tag17(&mut self) {
        self.tag17 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag17(&mut self, v: i64) {
        self.tag17 = v;
    }

    // int32 num_msgs = 18;


    pub fn get_num_msgs(&self) -> i32 {
        self.num_msgs
    }
    pub fn clear_num_msgs(&mut self) {
        self.num_msgs = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_msgs(&mut self, v: i32) {
        self.num_msgs = v;
    }

    // int32 msgnum = 19;


    pub fn get_msgnum(&self) -> i32 {
        self.msgnum
    }
    pub fn clear_msgnum(&mut self) {
        self.msgnum = 0;
    }

    // Param is passed by value, moved
    pub fn set_msgnum(&mut self, v: i32) {
        self.msgnum = v;
    }

    // .ZwiftPacketMonitor.EventPositions event_positions = 23;


    pub fn get_event_positions(&self) -> &EventPositions {
        self.event_positions.as_ref().unwrap_or_else(|| <EventPositions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_event_positions(&mut self) {
        self.event_positions.clear();
    }

    pub fn has_event_positions(&self) -> bool {
        self.event_positions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_positions(&mut self, v: EventPositions) {
        self.event_positions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_positions(&mut self) -> &mut EventPositions {
        if self.event_positions.is_none() {
            self.event_positions.set_default();
        }
        self.event_positions.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_positions(&mut self) -> EventPositions {
        self.event_positions.take().unwrap_or_else(|| EventPositions::new())
    }

    // .ZwiftPacketMonitor.Server1 servers1 = 24;


    pub fn get_servers1(&self) -> &Server1 {
        self.servers1.as_ref().unwrap_or_else(|| <Server1 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_servers1(&mut self) {
        self.servers1.clear();
    }

    pub fn has_servers1(&self) -> bool {
        self.servers1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers1(&mut self, v: Server1) {
        self.servers1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_servers1(&mut self) -> &mut Server1 {
        if self.servers1.is_none() {
            self.servers1.set_default();
        }
        self.servers1.as_mut().unwrap()
    }

    // Take field
    pub fn take_servers1(&mut self) -> Server1 {
        self.servers1.take().unwrap_or_else(|| Server1::new())
    }

    // .ZwiftPacketMonitor.Server2 servers2 = 25;


    pub fn get_servers2(&self) -> &Server2 {
        self.servers2.as_ref().unwrap_or_else(|| <Server2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_servers2(&mut self) {
        self.servers2.clear();
    }

    pub fn has_servers2(&self) -> bool {
        self.servers2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers2(&mut self, v: Server2) {
        self.servers2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_servers2(&mut self) -> &mut Server2 {
        if self.servers2.is_none() {
            self.servers2.set_default();
        }
        self.servers2.as_mut().unwrap()
    }

    // Take field
    pub fn take_servers2(&mut self) -> Server2 {
        self.servers2.take().unwrap_or_else(|| Server2::new())
    }
}

impl ::protobuf::Message for ServerToClient {
    fn is_initialized(&self) -> bool {
        for v in &self.player_states {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_positions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.servers1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.servers2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tag1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rider_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.world_time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seqno = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_states)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_updates)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag11 = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_ip)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tag15 = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag17 = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_msgs = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.msgnum = tmp;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_positions)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.servers1)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.servers2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tag1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rider_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.rider_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.world_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.world_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seqno != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seqno, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.player_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.player_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.tag11 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.tag11, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.local_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.local_ip);
        }
        if self.tag15 != 0 {
            my_size += ::protobuf::rt::value_size(15, self.tag15, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag17 != 0 {
            my_size += ::protobuf::rt::value_size(17, self.tag17, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_msgs != 0 {
            my_size += ::protobuf::rt::value_size(18, self.num_msgs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.msgnum != 0 {
            my_size += ::protobuf::rt::value_size(19, self.msgnum, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.event_positions.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.servers1.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.servers2.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tag1 != 0 {
            os.write_int32(1, self.tag1)?;
        }
        if self.rider_id != 0 {
            os.write_int32(2, self.rider_id)?;
        }
        if self.world_time != 0 {
            os.write_int64(3, self.world_time)?;
        }
        if self.seqno != 0 {
            os.write_int32(4, self.seqno)?;
        }
        for v in &self.player_states {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.player_updates {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.tag11 != 0 {
            os.write_int64(11, self.tag11)?;
        }
        if !self.local_ip.is_empty() {
            os.write_string(12, &self.local_ip)?;
        }
        if self.tag15 != 0 {
            os.write_int32(15, self.tag15)?;
        }
        if self.tag17 != 0 {
            os.write_int64(17, self.tag17)?;
        }
        if self.num_msgs != 0 {
            os.write_int32(18, self.num_msgs)?;
        }
        if self.msgnum != 0 {
            os.write_int32(19, self.msgnum)?;
        }
        if let Some(ref v) = self.event_positions.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.servers1.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.servers2.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerToClient {
        ServerToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tag1",
                |m: &ServerToClient| { &m.tag1 },
                |m: &mut ServerToClient| { &mut m.tag1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rider_id",
                |m: &ServerToClient| { &m.rider_id },
                |m: &mut ServerToClient| { &mut m.rider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "world_time",
                |m: &ServerToClient| { &m.world_time },
                |m: &mut ServerToClient| { &mut m.world_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seqno",
                |m: &ServerToClient| { &m.seqno },
                |m: &mut ServerToClient| { &mut m.seqno },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerState>>(
                "player_states",
                |m: &ServerToClient| { &m.player_states },
                |m: &mut ServerToClient| { &mut m.player_states },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerUpdate>>(
                "player_updates",
                |m: &ServerToClient| { &m.player_updates },
                |m: &mut ServerToClient| { &mut m.player_updates },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag11",
                |m: &ServerToClient| { &m.tag11 },
                |m: &mut ServerToClient| { &mut m.tag11 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_ip",
                |m: &ServerToClient| { &m.local_ip },
                |m: &mut ServerToClient| { &mut m.local_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tag15",
                |m: &ServerToClient| { &m.tag15 },
                |m: &mut ServerToClient| { &mut m.tag15 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag17",
                |m: &ServerToClient| { &m.tag17 },
                |m: &mut ServerToClient| { &mut m.tag17 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_msgs",
                |m: &ServerToClient| { &m.num_msgs },
                |m: &mut ServerToClient| { &mut m.num_msgs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "msgnum",
                |m: &ServerToClient| { &m.msgnum },
                |m: &mut ServerToClient| { &mut m.msgnum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventPositions>>(
                "event_positions",
                |m: &ServerToClient| { &m.event_positions },
                |m: &mut ServerToClient| { &mut m.event_positions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server1>>(
                "servers1",
                |m: &ServerToClient| { &m.servers1 },
                |m: &mut ServerToClient| { &mut m.servers1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server2>>(
                "servers2",
                |m: &ServerToClient| { &m.servers2 },
                |m: &mut ServerToClient| { &mut m.servers2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerToClient>(
                "ServerToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerToClient {
        static instance: ::protobuf::rt::LazyV2<ServerToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerToClient::new)
    }
}

impl ::protobuf::Clear for ServerToClient {
    fn clear(&mut self) {
        self.tag1 = 0;
        self.rider_id = 0;
        self.world_time = 0;
        self.seqno = 0;
        self.player_states.clear();
        self.player_updates.clear();
        self.tag11 = 0;
        self.local_ip.clear();
        self.tag15 = 0;
        self.tag17 = 0;
        self.num_msgs = 0;
        self.msgnum = 0;
        self.event_positions.clear();
        self.servers1.clear();
        self.servers2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerAddress {
    // message fields
    pub f1: i32,
    pub f2: i32,
    pub ip: ::std::string::String,
    pub f4: i32,
    pub f5: u32,
    pub f6: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerAddress {
    fn default() -> &'a ServerAddress {
        <ServerAddress as ::protobuf::Message>::default_instance()
    }
}

impl ServerAddress {
    pub fn new() -> ServerAddress {
        ::std::default::Default::default()
    }

    // int32 f1 = 1;


    pub fn get_f1(&self) -> i32 {
        self.f1
    }
    pub fn clear_f1(&mut self) {
        self.f1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: i32) {
        self.f1 = v;
    }

    // int32 f2 = 2;


    pub fn get_f2(&self) -> i32 {
        self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: i32) {
        self.f2 = v;
    }

    // string ip = 3;


    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }

    // int32 f4 = 4;


    pub fn get_f4(&self) -> i32 {
        self.f4
    }
    pub fn clear_f4(&mut self) {
        self.f4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f4(&mut self, v: i32) {
        self.f4 = v;
    }

    // fixed32 f5 = 5;


    pub fn get_f5(&self) -> u32 {
        self.f5
    }
    pub fn clear_f5(&mut self) {
        self.f5 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f5(&mut self, v: u32) {
        self.f5 = v;
    }

    // fixed32 f6 = 6;


    pub fn get_f6(&self) -> u32 {
        self.f6
    }
    pub fn clear_f6(&mut self) {
        self.f6 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f6(&mut self, v: u32) {
        self.f6 = v;
    }
}

impl ::protobuf::Message for ServerAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f2 = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f4 = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.f5 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.f6 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.f1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.f1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f2, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ip);
        }
        if self.f4 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.f4, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f5 != 0 {
            my_size += 5;
        }
        if self.f6 != 0 {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.f1 != 0 {
            os.write_int32(1, self.f1)?;
        }
        if self.f2 != 0 {
            os.write_int32(2, self.f2)?;
        }
        if !self.ip.is_empty() {
            os.write_string(3, &self.ip)?;
        }
        if self.f4 != 0 {
            os.write_int32(4, self.f4)?;
        }
        if self.f5 != 0 {
            os.write_fixed32(5, self.f5)?;
        }
        if self.f6 != 0 {
            os.write_fixed32(6, self.f6)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerAddress {
        ServerAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f1",
                |m: &ServerAddress| { &m.f1 },
                |m: &mut ServerAddress| { &mut m.f1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f2",
                |m: &ServerAddress| { &m.f2 },
                |m: &mut ServerAddress| { &mut m.f2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &ServerAddress| { &m.ip },
                |m: &mut ServerAddress| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f4",
                |m: &ServerAddress| { &m.f4 },
                |m: &mut ServerAddress| { &mut m.f4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "f5",
                |m: &ServerAddress| { &m.f5 },
                |m: &mut ServerAddress| { &mut m.f5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "f6",
                |m: &ServerAddress| { &m.f6 },
                |m: &mut ServerAddress| { &mut m.f6 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerAddress>(
                "ServerAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerAddress {
        static instance: ::protobuf::rt::LazyV2<ServerAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerAddress::new)
    }
}

impl ::protobuf::Clear for ServerAddress {
    fn clear(&mut self) {
        self.f1 = 0;
        self.f2 = 0;
        self.ip.clear();
        self.f4 = 0;
        self.f5 = 0;
        self.f6 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerPool {
    // message fields
    pub f1: i32,
    pub f2: i32,
    pub addresses: ::protobuf::RepeatedField<ServerAddress>,
    pub f4: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerPool {
    fn default() -> &'a ServerPool {
        <ServerPool as ::protobuf::Message>::default_instance()
    }
}

impl ServerPool {
    pub fn new() -> ServerPool {
        ::std::default::Default::default()
    }

    // int32 f1 = 1;


    pub fn get_f1(&self) -> i32 {
        self.f1
    }
    pub fn clear_f1(&mut self) {
        self.f1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: i32) {
        self.f1 = v;
    }

    // int32 f2 = 2;


    pub fn get_f2(&self) -> i32 {
        self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: i32) {
        self.f2 = v;
    }

    // repeated .ZwiftPacketMonitor.ServerAddress addresses = 3;


    pub fn get_addresses(&self) -> &[ServerAddress] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<ServerAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<ServerAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<ServerAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // int32 f4 = 4;


    pub fn get_f4(&self) -> i32 {
        self.f4
    }
    pub fn clear_f4(&mut self) {
        self.f4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f4(&mut self, v: i32) {
        self.f4 = v;
    }
}

impl ::protobuf::Message for ServerPool {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f2 = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f4 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.f1 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.f1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f2, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.f4 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.f4, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.f1 != 0 {
            os.write_int32(1, self.f1)?;
        }
        if self.f2 != 0 {
            os.write_int32(2, self.f2)?;
        }
        for v in &self.addresses {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.f4 != 0 {
            os.write_int32(4, self.f4)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerPool {
        ServerPool::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f1",
                |m: &ServerPool| { &m.f1 },
                |m: &mut ServerPool| { &mut m.f1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f2",
                |m: &ServerPool| { &m.f2 },
                |m: &mut ServerPool| { &mut m.f2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerAddress>>(
                "addresses",
                |m: &ServerPool| { &m.addresses },
                |m: &mut ServerPool| { &mut m.addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f4",
                |m: &ServerPool| { &m.f4 },
                |m: &mut ServerPool| { &mut m.f4 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerPool>(
                "ServerPool",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerPool {
        static instance: ::protobuf::rt::LazyV2<ServerPool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerPool::new)
    }
}

impl ::protobuf::Clear for ServerPool {
    fn clear(&mut self) {
        self.f1 = 0;
        self.f2 = 0;
        self.addresses.clear();
        self.f4 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerPool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Server2 {
    // message fields
    pub pool: ::protobuf::RepeatedField<ServerPool>,
    pub f2: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Server2 {
    fn default() -> &'a Server2 {
        <Server2 as ::protobuf::Message>::default_instance()
    }
}

impl Server2 {
    pub fn new() -> Server2 {
        ::std::default::Default::default()
    }

    // repeated .ZwiftPacketMonitor.ServerPool pool = 1;


    pub fn get_pool(&self) -> &[ServerPool] {
        &self.pool
    }
    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::protobuf::RepeatedField<ServerPool>) {
        self.pool = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pool(&mut self) -> &mut ::protobuf::RepeatedField<ServerPool> {
        &mut self.pool
    }

    // Take field
    pub fn take_pool(&mut self) -> ::protobuf::RepeatedField<ServerPool> {
        ::std::mem::replace(&mut self.pool, ::protobuf::RepeatedField::new())
    }

    // int32 f2 = 2;


    pub fn get_f2(&self) -> i32 {
        self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: i32) {
        self.f2 = v;
    }
}

impl ::protobuf::Message for Server2 {
    fn is_initialized(&self) -> bool {
        for v in &self.pool {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pool)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f2 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pool {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.f2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f2, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pool {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.f2 != 0 {
            os.write_int32(2, self.f2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Server2 {
        Server2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerPool>>(
                "pool",
                |m: &Server2| { &m.pool },
                |m: &mut Server2| { &mut m.pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f2",
                |m: &Server2| { &m.f2 },
                |m: &mut Server2| { &mut m.f2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Server2>(
                "Server2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Server2 {
        static instance: ::protobuf::rt::LazyV2<Server2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Server2::new)
    }
}

impl ::protobuf::Clear for Server2 {
    fn clear(&mut self) {
        self.pool.clear();
        self.f2 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Server2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Server2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Server1 {
    // message fields
    pub addresses: ::protobuf::RepeatedField<ServerAddress>,
    pub f2: i32,
    pub f3: i32,
    pub f4: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Server1 {
    fn default() -> &'a Server1 {
        <Server1 as ::protobuf::Message>::default_instance()
    }
}

impl Server1 {
    pub fn new() -> Server1 {
        ::std::default::Default::default()
    }

    // repeated .ZwiftPacketMonitor.ServerAddress addresses = 1;


    pub fn get_addresses(&self) -> &[ServerAddress] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<ServerAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<ServerAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<ServerAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // int32 f2 = 2;


    pub fn get_f2(&self) -> i32 {
        self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: i32) {
        self.f2 = v;
    }

    // int32 f3 = 3;


    pub fn get_f3(&self) -> i32 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: i32) {
        self.f3 = v;
    }

    // int32 f4 = 4;


    pub fn get_f4(&self) -> i32 {
        self.f4
    }
    pub fn clear_f4(&mut self) {
        self.f4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f4(&mut self, v: i32) {
        self.f4 = v;
    }
}

impl ::protobuf::Message for Server1 {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f3 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f4 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.f2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f4 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.f4, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.f2 != 0 {
            os.write_int32(2, self.f2)?;
        }
        if self.f3 != 0 {
            os.write_int32(3, self.f3)?;
        }
        if self.f4 != 0 {
            os.write_int32(4, self.f4)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Server1 {
        Server1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerAddress>>(
                "addresses",
                |m: &Server1| { &m.addresses },
                |m: &mut Server1| { &mut m.addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f2",
                |m: &Server1| { &m.f2 },
                |m: &mut Server1| { &mut m.f2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f3",
                |m: &Server1| { &m.f3 },
                |m: &mut Server1| { &mut m.f3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f4",
                |m: &Server1| { &m.f4 },
                |m: &mut Server1| { &mut m.f4 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Server1>(
                "Server1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Server1 {
        static instance: ::protobuf::rt::LazyV2<Server1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Server1::new)
    }
}

impl ::protobuf::Clear for Server1 {
    fn clear(&mut self) {
        self.addresses.clear();
        self.f2 = 0;
        self.f3 = 0;
        self.f4 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Server1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Server1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorldAttributes {
    // message fields
    pub world_id: i32,
    pub name: ::std::string::String,
    pub tag3: i64,
    pub tag5: i64,
    pub world_time: i64,
    pub clock_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorldAttributes {
    fn default() -> &'a WorldAttributes {
        <WorldAttributes as ::protobuf::Message>::default_instance()
    }
}

impl WorldAttributes {
    pub fn new() -> WorldAttributes {
        ::std::default::Default::default()
    }

    // int32 world_id = 1;


    pub fn get_world_id(&self) -> i32 {
        self.world_id
    }
    pub fn clear_world_id(&mut self) {
        self.world_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_world_id(&mut self, v: i32) {
        self.world_id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 tag3 = 3;


    pub fn get_tag3(&self) -> i64 {
        self.tag3
    }
    pub fn clear_tag3(&mut self) {
        self.tag3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag3(&mut self, v: i64) {
        self.tag3 = v;
    }

    // int64 tag5 = 4;


    pub fn get_tag5(&self) -> i64 {
        self.tag5
    }
    pub fn clear_tag5(&mut self) {
        self.tag5 = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag5(&mut self, v: i64) {
        self.tag5 = v;
    }

    // int64 world_time = 6;


    pub fn get_world_time(&self) -> i64 {
        self.world_time
    }
    pub fn clear_world_time(&mut self) {
        self.world_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_world_time(&mut self, v: i64) {
        self.world_time = v;
    }

    // int64 clock_time = 7;


    pub fn get_clock_time(&self) -> i64 {
        self.clock_time
    }
    pub fn clear_clock_time(&mut self) {
        self.clock_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_clock_time(&mut self, v: i64) {
        self.clock_time = v;
    }
}

impl ::protobuf::Message for WorldAttributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.world_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag3 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tag5 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.world_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.clock_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.world_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.world_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.tag3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.tag3, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag5 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.tag5, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.world_time != 0 {
            my_size += ::protobuf::rt::value_size(6, self.world_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.clock_time != 0 {
            my_size += ::protobuf::rt::value_size(7, self.clock_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.world_id != 0 {
            os.write_int32(1, self.world_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.tag3 != 0 {
            os.write_int64(3, self.tag3)?;
        }
        if self.tag5 != 0 {
            os.write_int64(4, self.tag5)?;
        }
        if self.world_time != 0 {
            os.write_int64(6, self.world_time)?;
        }
        if self.clock_time != 0 {
            os.write_int64(7, self.clock_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorldAttributes {
        WorldAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "world_id",
                |m: &WorldAttributes| { &m.world_id },
                |m: &mut WorldAttributes| { &mut m.world_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &WorldAttributes| { &m.name },
                |m: &mut WorldAttributes| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag3",
                |m: &WorldAttributes| { &m.tag3 },
                |m: &mut WorldAttributes| { &mut m.tag3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tag5",
                |m: &WorldAttributes| { &m.tag5 },
                |m: &mut WorldAttributes| { &mut m.tag5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "world_time",
                |m: &WorldAttributes| { &m.world_time },
                |m: &mut WorldAttributes| { &mut m.world_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "clock_time",
                |m: &WorldAttributes| { &m.clock_time },
                |m: &mut WorldAttributes| { &mut m.clock_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorldAttributes>(
                "WorldAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorldAttributes {
        static instance: ::protobuf::rt::LazyV2<WorldAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorldAttributes::new)
    }
}

impl ::protobuf::Clear for WorldAttributes {
    fn clear(&mut self) {
        self.world_id = 0;
        self.name.clear();
        self.tag3 = 0;
        self.tag5 = 0;
        self.world_time = 0;
        self.clock_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorldAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorldAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorldAttribute {
    // message fields
    pub world_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorldAttribute {
    fn default() -> &'a WorldAttribute {
        <WorldAttribute as ::protobuf::Message>::default_instance()
    }
}

impl WorldAttribute {
    pub fn new() -> WorldAttribute {
        ::std::default::Default::default()
    }

    // int64 world_time = 2;


    pub fn get_world_time(&self) -> i64 {
        self.world_time
    }
    pub fn clear_world_time(&mut self) {
        self.world_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_world_time(&mut self, v: i64) {
        self.world_time = v;
    }
}

impl ::protobuf::Message for WorldAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.world_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.world_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.world_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.world_time != 0 {
            os.write_int64(2, self.world_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorldAttribute {
        WorldAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "world_time",
                |m: &WorldAttribute| { &m.world_time },
                |m: &mut WorldAttribute| { &mut m.world_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorldAttribute>(
                "WorldAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorldAttribute {
        static instance: ::protobuf::rt::LazyV2<WorldAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorldAttribute::new)
    }
}

impl ::protobuf::Clear for WorldAttribute {
    fn clear(&mut self) {
        self.world_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorldAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorldAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventSubgroupProtobuf {
    // message fields
    pub id: i32,
    pub name: ::std::string::String,
    pub rules: i32,
    pub route: i32,
    pub laps: i32,
    pub startLocation: i32,
    pub label: i32,
    pub paceType: i32,
    pub jerseyHash: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventSubgroupProtobuf {
    fn default() -> &'a EventSubgroupProtobuf {
        <EventSubgroupProtobuf as ::protobuf::Message>::default_instance()
    }
}

impl EventSubgroupProtobuf {
    pub fn new() -> EventSubgroupProtobuf {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 rules = 8;


    pub fn get_rules(&self) -> i32 {
        self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules = 0;
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: i32) {
        self.rules = v;
    }

    // int32 route = 22;


    pub fn get_route(&self) -> i32 {
        self.route
    }
    pub fn clear_route(&mut self) {
        self.route = 0;
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: i32) {
        self.route = v;
    }

    // int32 laps = 25;


    pub fn get_laps(&self) -> i32 {
        self.laps
    }
    pub fn clear_laps(&mut self) {
        self.laps = 0;
    }

    // Param is passed by value, moved
    pub fn set_laps(&mut self, v: i32) {
        self.laps = v;
    }

    // int32 startLocation = 29;


    pub fn get_startLocation(&self) -> i32 {
        self.startLocation
    }
    pub fn clear_startLocation(&mut self) {
        self.startLocation = 0;
    }

    // Param is passed by value, moved
    pub fn set_startLocation(&mut self, v: i32) {
        self.startLocation = v;
    }

    // int32 label = 30;


    pub fn get_label(&self) -> i32 {
        self.label
    }
    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: i32) {
        self.label = v;
    }

    // int32 paceType = 31;


    pub fn get_paceType(&self) -> i32 {
        self.paceType
    }
    pub fn clear_paceType(&mut self) {
        self.paceType = 0;
    }

    // Param is passed by value, moved
    pub fn set_paceType(&mut self, v: i32) {
        self.paceType = v;
    }

    // int32 jerseyHash = 36;


    pub fn get_jerseyHash(&self) -> i32 {
        self.jerseyHash
    }
    pub fn clear_jerseyHash(&mut self) {
        self.jerseyHash = 0;
    }

    // Param is passed by value, moved
    pub fn set_jerseyHash(&mut self, v: i32) {
        self.jerseyHash = v;
    }
}

impl ::protobuf::Message for EventSubgroupProtobuf {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rules = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.route = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.laps = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.startLocation = tmp;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.paceType = tmp;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.jerseyHash = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.rules != 0 {
            my_size += ::protobuf::rt::value_size(8, self.rules, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.route != 0 {
            my_size += ::protobuf::rt::value_size(22, self.route, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.laps != 0 {
            my_size += ::protobuf::rt::value_size(25, self.laps, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.startLocation != 0 {
            my_size += ::protobuf::rt::value_size(29, self.startLocation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(30, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.paceType != 0 {
            my_size += ::protobuf::rt::value_size(31, self.paceType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.jerseyHash != 0 {
            my_size += ::protobuf::rt::value_size(36, self.jerseyHash, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.rules != 0 {
            os.write_int32(8, self.rules)?;
        }
        if self.route != 0 {
            os.write_int32(22, self.route)?;
        }
        if self.laps != 0 {
            os.write_int32(25, self.laps)?;
        }
        if self.startLocation != 0 {
            os.write_int32(29, self.startLocation)?;
        }
        if self.label != 0 {
            os.write_int32(30, self.label)?;
        }
        if self.paceType != 0 {
            os.write_int32(31, self.paceType)?;
        }
        if self.jerseyHash != 0 {
            os.write_int32(36, self.jerseyHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventSubgroupProtobuf {
        EventSubgroupProtobuf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &EventSubgroupProtobuf| { &m.id },
                |m: &mut EventSubgroupProtobuf| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &EventSubgroupProtobuf| { &m.name },
                |m: &mut EventSubgroupProtobuf| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rules",
                |m: &EventSubgroupProtobuf| { &m.rules },
                |m: &mut EventSubgroupProtobuf| { &mut m.rules },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "route",
                |m: &EventSubgroupProtobuf| { &m.route },
                |m: &mut EventSubgroupProtobuf| { &mut m.route },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "laps",
                |m: &EventSubgroupProtobuf| { &m.laps },
                |m: &mut EventSubgroupProtobuf| { &mut m.laps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "startLocation",
                |m: &EventSubgroupProtobuf| { &m.startLocation },
                |m: &mut EventSubgroupProtobuf| { &mut m.startLocation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "label",
                |m: &EventSubgroupProtobuf| { &m.label },
                |m: &mut EventSubgroupProtobuf| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "paceType",
                |m: &EventSubgroupProtobuf| { &m.paceType },
                |m: &mut EventSubgroupProtobuf| { &mut m.paceType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "jerseyHash",
                |m: &EventSubgroupProtobuf| { &m.jerseyHash },
                |m: &mut EventSubgroupProtobuf| { &mut m.jerseyHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventSubgroupProtobuf>(
                "EventSubgroupProtobuf",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventSubgroupProtobuf {
        static instance: ::protobuf::rt::LazyV2<EventSubgroupProtobuf> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventSubgroupProtobuf::new)
    }
}

impl ::protobuf::Clear for EventSubgroupProtobuf {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.rules = 0;
        self.route = 0;
        self.laps = 0;
        self.startLocation = 0;
        self.label = 0;
        self.paceType = 0;
        self.jerseyHash = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventSubgroupProtobuf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSubgroupProtobuf {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RiderAttributes {
    // message fields
    pub f2: i32,
    pub f3: i32,
    pub attributeMessage: ::protobuf::SingularPtrField<RiderAttributes_AttributeMessage>,
    pub theirId: i32,
    pub f13: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RiderAttributes {
    fn default() -> &'a RiderAttributes {
        <RiderAttributes as ::protobuf::Message>::default_instance()
    }
}

impl RiderAttributes {
    pub fn new() -> RiderAttributes {
        ::std::default::Default::default()
    }

    // int32 f2 = 2;


    pub fn get_f2(&self) -> i32 {
        self.f2
    }
    pub fn clear_f2(&mut self) {
        self.f2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f2(&mut self, v: i32) {
        self.f2 = v;
    }

    // int32 f3 = 3;


    pub fn get_f3(&self) -> i32 {
        self.f3
    }
    pub fn clear_f3(&mut self) {
        self.f3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f3(&mut self, v: i32) {
        self.f3 = v;
    }

    // .ZwiftPacketMonitor.RiderAttributes.AttributeMessage attributeMessage = 4;


    pub fn get_attributeMessage(&self) -> &RiderAttributes_AttributeMessage {
        self.attributeMessage.as_ref().unwrap_or_else(|| <RiderAttributes_AttributeMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributeMessage(&mut self) {
        self.attributeMessage.clear();
    }

    pub fn has_attributeMessage(&self) -> bool {
        self.attributeMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributeMessage(&mut self, v: RiderAttributes_AttributeMessage) {
        self.attributeMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributeMessage(&mut self) -> &mut RiderAttributes_AttributeMessage {
        if self.attributeMessage.is_none() {
            self.attributeMessage.set_default();
        }
        self.attributeMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributeMessage(&mut self) -> RiderAttributes_AttributeMessage {
        self.attributeMessage.take().unwrap_or_else(|| RiderAttributes_AttributeMessage::new())
    }

    // int32 theirId = 10;


    pub fn get_theirId(&self) -> i32 {
        self.theirId
    }
    pub fn clear_theirId(&mut self) {
        self.theirId = 0;
    }

    // Param is passed by value, moved
    pub fn set_theirId(&mut self, v: i32) {
        self.theirId = v;
    }

    // int32 f13 = 13;


    pub fn get_f13(&self) -> i32 {
        self.f13
    }
    pub fn clear_f13(&mut self) {
        self.f13 = 0;
    }

    // Param is passed by value, moved
    pub fn set_f13(&mut self, v: i32) {
        self.f13 = v;
    }
}

impl ::protobuf::Message for RiderAttributes {
    fn is_initialized(&self) -> bool {
        for v in &self.attributeMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f3 = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributeMessage)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.theirId = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.f13 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.f2 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f3 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f3, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attributeMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.theirId != 0 {
            my_size += ::protobuf::rt::value_size(10, self.theirId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f13 != 0 {
            my_size += ::protobuf::rt::value_size(13, self.f13, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.f2 != 0 {
            os.write_int32(2, self.f2)?;
        }
        if self.f3 != 0 {
            os.write_int32(3, self.f3)?;
        }
        if let Some(ref v) = self.attributeMessage.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.theirId != 0 {
            os.write_int32(10, self.theirId)?;
        }
        if self.f13 != 0 {
            os.write_int32(13, self.f13)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RiderAttributes {
        RiderAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f2",
                |m: &RiderAttributes| { &m.f2 },
                |m: &mut RiderAttributes| { &mut m.f2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f3",
                |m: &RiderAttributes| { &m.f3 },
                |m: &mut RiderAttributes| { &mut m.f3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiderAttributes_AttributeMessage>>(
                "attributeMessage",
                |m: &RiderAttributes| { &m.attributeMessage },
                |m: &mut RiderAttributes| { &mut m.attributeMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "theirId",
                |m: &RiderAttributes| { &m.theirId },
                |m: &mut RiderAttributes| { &mut m.theirId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "f13",
                |m: &RiderAttributes| { &m.f13 },
                |m: &mut RiderAttributes| { &mut m.f13 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RiderAttributes>(
                "RiderAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RiderAttributes {
        static instance: ::protobuf::rt::LazyV2<RiderAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RiderAttributes::new)
    }
}

impl ::protobuf::Clear for RiderAttributes {
    fn clear(&mut self) {
        self.f2 = 0;
        self.f3 = 0;
        self.attributeMessage.clear();
        self.theirId = 0;
        self.f13 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RiderAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiderAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RiderAttributes_AttributeMessage {
    // message fields
    pub myId: i32,
    pub theirId: i32,
    pub firstName: ::std::string::String,
    pub lastName: ::std::string::String,
    pub countryCode: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RiderAttributes_AttributeMessage {
    fn default() -> &'a RiderAttributes_AttributeMessage {
        <RiderAttributes_AttributeMessage as ::protobuf::Message>::default_instance()
    }
}

impl RiderAttributes_AttributeMessage {
    pub fn new() -> RiderAttributes_AttributeMessage {
        ::std::default::Default::default()
    }

    // int32 myId = 1;


    pub fn get_myId(&self) -> i32 {
        self.myId
    }
    pub fn clear_myId(&mut self) {
        self.myId = 0;
    }

    // Param is passed by value, moved
    pub fn set_myId(&mut self, v: i32) {
        self.myId = v;
    }

    // int32 theirId = 2;


    pub fn get_theirId(&self) -> i32 {
        self.theirId
    }
    pub fn clear_theirId(&mut self) {
        self.theirId = 0;
    }

    // Param is passed by value, moved
    pub fn set_theirId(&mut self, v: i32) {
        self.theirId = v;
    }

    // string firstName = 3;


    pub fn get_firstName(&self) -> &str {
        &self.firstName
    }
    pub fn clear_firstName(&mut self) {
        self.firstName.clear();
    }

    // Param is passed by value, moved
    pub fn set_firstName(&mut self, v: ::std::string::String) {
        self.firstName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstName(&mut self) -> &mut ::std::string::String {
        &mut self.firstName
    }

    // Take field
    pub fn take_firstName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.firstName, ::std::string::String::new())
    }

    // string lastName = 4;


    pub fn get_lastName(&self) -> &str {
        &self.lastName
    }
    pub fn clear_lastName(&mut self) {
        self.lastName.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastName(&mut self, v: ::std::string::String) {
        self.lastName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastName(&mut self) -> &mut ::std::string::String {
        &mut self.lastName
    }

    // Take field
    pub fn take_lastName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastName, ::std::string::String::new())
    }

    // int32 countryCode = 5;


    pub fn get_countryCode(&self) -> i32 {
        self.countryCode
    }
    pub fn clear_countryCode(&mut self) {
        self.countryCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_countryCode(&mut self, v: i32) {
        self.countryCode = v;
    }
}

impl ::protobuf::Message for RiderAttributes_AttributeMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.myId = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.theirId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.firstName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastName)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.countryCode = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.myId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.myId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.theirId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.theirId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.firstName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.firstName);
        }
        if !self.lastName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.lastName);
        }
        if self.countryCode != 0 {
            my_size += ::protobuf::rt::value_size(5, self.countryCode, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.myId != 0 {
            os.write_int32(1, self.myId)?;
        }
        if self.theirId != 0 {
            os.write_int32(2, self.theirId)?;
        }
        if !self.firstName.is_empty() {
            os.write_string(3, &self.firstName)?;
        }
        if !self.lastName.is_empty() {
            os.write_string(4, &self.lastName)?;
        }
        if self.countryCode != 0 {
            os.write_int32(5, self.countryCode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RiderAttributes_AttributeMessage {
        RiderAttributes_AttributeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "myId",
                |m: &RiderAttributes_AttributeMessage| { &m.myId },
                |m: &mut RiderAttributes_AttributeMessage| { &mut m.myId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "theirId",
                |m: &RiderAttributes_AttributeMessage| { &m.theirId },
                |m: &mut RiderAttributes_AttributeMessage| { &mut m.theirId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstName",
                |m: &RiderAttributes_AttributeMessage| { &m.firstName },
                |m: &mut RiderAttributes_AttributeMessage| { &mut m.firstName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastName",
                |m: &RiderAttributes_AttributeMessage| { &m.lastName },
                |m: &mut RiderAttributes_AttributeMessage| { &mut m.lastName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "countryCode",
                |m: &RiderAttributes_AttributeMessage| { &m.countryCode },
                |m: &mut RiderAttributes_AttributeMessage| { &mut m.countryCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RiderAttributes_AttributeMessage>(
                "RiderAttributes.AttributeMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RiderAttributes_AttributeMessage {
        static instance: ::protobuf::rt::LazyV2<RiderAttributes_AttributeMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RiderAttributes_AttributeMessage::new)
    }
}

impl ::protobuf::Clear for RiderAttributes_AttributeMessage {
    fn clear(&mut self) {
        self.myId = 0;
        self.theirId = 0;
        self.firstName.clear();
        self.lastName.clear();
        self.countryCode = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RiderAttributes_AttributeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiderAttributes_AttributeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bprotos/zwift_messages.proto\x12\x12ZwiftPacketMonitor\"\xcc\x08\n\
    \x06Meetup\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04tag2\
    \x18\x02\x20\x01(\x05R\x04tag2\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04\
    name\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0bdescription\x12\x1d\
    \n\nstart_time\x18\x05\x20\x01(\x03R\tstartTime\x12\x1a\n\x08distance\
    \x18\x07\x20\x01(\x07R\x08distance\x12\x12\n\x04tag8\x18\x08\x20\x01(\
    \x05R\x04tag8\x12I\n\x0cmeetup_inner\x18\n\x20\x01(\x0b2&.ZwiftPacketMon\
    itor.Meetup.MeetupInnerR\x0bmeetupInner\x12\x1c\n\tthumbnail\x18\x0c\x20\
    \x01(\tR\tthumbnail\x12\x1a\n\x08duration\x18\r\x20\x01(\x05R\x08duratio\
    n\x12\x10\n\x03f14\x18\x0e\x20\x01(\x03R\x03f14\x12\x10\n\x03f17\x18\x11\
    \x20\x01(\x05R\x03f17\x12\x10\n\x03f18\x18\x12\x20\x01(\x05R\x03f18\x12\
    \x10\n\x03f22\x18\x16\x20\x01(\x05R\x03f22\x12\x10\n\x03f23\x18\x17\x20\
    \x01(\x05R\x03f23\x12(\n\x10meetup_only_view\x18\x18\x20\x01(\x05R\x0eme\
    etupOnlyView\x12\x10\n\x03f25\x18\x19\x20\x01(\x05R\x03f25\x12\x10\n\x03\
    f27\x18\x1b\x20\x01(\x05R\x03f27\x12\x10\n\x03f28\x18\x1c\x20\x01(\x05R\
    \x03f28\x12\x10\n\x03f29\x18\x1d\x20\x01(\x05R\x03f29\x12\x10\n\x03f34\
    \x18\"\x20\x01(\x05R\x03f34\x12\x10\n\x03f35\x18#\x20\x01(\x05R\x03f35\
    \x1a\xa3\x04\n\x0bMeetupInner\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02i\
    d\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\
    \x18\x03\x20\x01(\tR\x0bdescription\x12\x0e\n\x02f7\x18\x07\x20\x01(\tR\
    \x02f7\x12\x0e\n\x02f8\x18\x08\x20\x01(\x03R\x02f8\x12\x0e\n\x02f9\x18\t\
    \x20\x01(\x03R\x02f9\x12\x10\n\x03f10\x18\n\x20\x01(\x03R\x03f10\x12\x10\
    \n\x03f11\x18\x0b\x20\x01(\x03R\x03f11\x12\x10\n\x03f12\x18\x0c\x20\x01(\
    \x03R\x03f12\x12\x10\n\x03f13\x18\r\x20\x01(\x03R\x03f13\x12\x10\n\x03f1\
    4\x18\x0e\x20\x01(\x03R\x03f14\x12\x10\n\x03f15\x18\x0f\x20\x01(\x03R\
    \x03f15\x12\x10\n\x03f16\x18\x10\x20\x01(\x03R\x03f16\x12\x10\n\x03f17\
    \x18\x11\x20\x01(\x03R\x03f17\x12\x10\n\x03f18\x18\x12\x20\x01(\x03R\x03\
    f18\x12\x10\n\x03f22\x18\x16\x20\x01(\x03R\x03f22\x12\x1a\n\x08distance\
    \x18\x18\x20\x01(\x07R\x08distance\x12\x10\n\x03f25\x18\x19\x20\x01(\x03\
    R\x03f25\x12\x10\n\x03f29\x18\x1d\x20\x01(\x05R\x03f29\x12\x10\n\x03f30\
    \x18\x1e\x20\x01(\x05R\x03f30\x12\x10\n\x03f31\x18\x1f\x20\x01(\x05R\x03\
    f31\x12\x10\n\x03f32\x18\x20\x20\x01(\x07R\x03f32\x12\x10\n\x03f33\x18!\
    \x20\x01(\x07R\x03f33\x12\x1a\n\x08duration\x18\"\x20\x01(\x05R\x08durat\
    ion\x12\x10\n\x03f42\x18*\x20\x01(\x03R\x03f42\x12\x10\n\x03f44\x18,\x20\
    \x01(\x03R\x03f44\x12\x10\n\x03f46\x18.\x20\x01(\x05R\x03f46\x12\x10\n\
    \x03f47\x18/\x20\x01(\x05R\x03f47\"\xc1\x05\n\x0bPlayerState\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x05R\x02id\x12\x1c\n\tworldTime\x18\x02\x20\x01(\
    \x03R\tworldTime\x12\x1a\n\x08distance\x18\x03\x20\x01(\x05R\x08distance\
    \x12\x1a\n\x08roadTime\x18\x04\x20\x01(\x05R\x08roadTime\x12\x12\n\x04la\
    ps\x18\x05\x20\x01(\x05R\x04laps\x12\x14\n\x05speed\x18\x06\x20\x01(\x05\
    R\x05speed\x12\"\n\x0croadPosition\x18\x08\x20\x01(\x05R\x0croadPosition\
    \x12\x1e\n\ncadenceUHz\x18\t\x20\x01(\x05R\ncadenceUHz\x12\x1c\n\theartr\
    ate\x18\x0b\x20\x01(\x05R\theartrate\x12\x14\n\x05power\x18\x0c\x20\x01(\
    \x05R\x05power\x12\x18\n\x07heading\x18\r\x20\x01(\x03R\x07heading\x12\
    \x12\n\x04lean\x18\x0e\x20\x01(\x05R\x04lean\x12\x1a\n\x08climbing\x18\
    \x0f\x20\x01(\x05R\x08climbing\x12\x12\n\x04time\x18\x10\x20\x01(\x05R\
    \x04time\x12\x10\n\x03f19\x18\x13\x20\x01(\x05R\x03f19\x12\x10\n\x03f20\
    \x18\x14\x20\x01(\x05R\x03f20\x12\x1a\n\x08progress\x18\x15\x20\x01(\x05\
    R\x08progress\x12(\n\x0fcustomisationId\x18\x16\x20\x01(\x03R\x0fcustomi\
    sationId\x12\"\n\x0cjustWatching\x18\x17\x20\x01(\x05R\x0cjustWatching\
    \x12\x1a\n\x08calories\x18\x18\x20\x01(\x05R\x08calories\x12\x0c\n\x01x\
    \x18\x19\x20\x01(\x02R\x01x\x12\x1a\n\x08altitude\x18\x1a\x20\x01(\x02R\
    \x08altitude\x12\x0c\n\x01y\x18\x1b\x20\x01(\x02R\x01y\x12(\n\x0fwatchin\
    gRiderId\x18\x1c\x20\x01(\x05R\x0fwatchingRiderId\x12\x18\n\x07groupId\
    \x18\x1d\x20\x01(\x05R\x07groupId\x12\x14\n\x05sport\x18\x1f\x20\x01(\
    \x03R\x05sport\x12\x10\n\x03f34\x18\"\x20\x01(\x02R\x03f34\"\xc2\x02\n\
    \x0eClientToServer\x12\x1c\n\tconnected\x18\x01\x20\x01(\x05R\tconnected\
    \x12\x19\n\x08rider_id\x18\x02\x20\x01(\x05R\x07riderId\x12\x1d\n\nworld\
    _time\x18\x03\x20\x01(\x03R\tworldTime\x12\x14\n\x05seqno\x18\x04\x20\
    \x01(\x05R\x05seqno\x125\n\x05state\x18\x07\x20\x01(\x0b2\x1f.ZwiftPacke\
    tMonitor.PlayerStateR\x05state\x12\x12\n\x04tag8\x18\x08\x20\x01(\x03R\
    \x04tag8\x12\x12\n\x04tag9\x18\t\x20\x01(\x03R\x04tag9\x12\x1f\n\x0blast\
    _update\x18\n\x20\x01(\x03R\nlastUpdate\x12\x14\n\x05tag11\x18\x0b\x20\
    \x01(\x03R\x05tag11\x12,\n\x12last_player_update\x18\x0c\x20\x01(\x03R\
    \x10lastPlayerUpdate\"\x11\n\x0fUnknownMessage1\"\x10\n\x0eUnknownMessag\
    e\"\xa0\x02\n\x0cPlayerUpdate\x12\x12\n\x04tag1\x18\x01\x20\x01(\x03R\
    \x04tag1\x12\x12\n\x04tag2\x18\x02\x20\x01(\x05R\x04tag2\x12\x12\n\x04ta\
    g3\x18\x03\x20\x01(\x05R\x04tag3\x12\x18\n\x07payload\x18\x04\x20\x01(\
    \x0cR\x07payload\x12\x12\n\x04tag5\x18\x05\x20\x01(\x03R\x04tag5\x12\x12\
    \n\x04tag6\x18\x06\x20\x01(\x03R\x04tag6\x12\x12\n\x04tag7\x18\x07\x20\
    \x01(\x03R\x04tag7\x12\x12\n\x04tag8\x18\x08\x20\x01(\x03R\x04tag8\x12\
    \x12\n\x04tag9\x18\t\x20\x01(\x03R\x04tag9\x12\x14\n\x05tag11\x18\x0b\
    \x20\x01(\x03R\x05tag11\x12\x14\n\x05tag12\x18\x0c\x20\x01(\x03R\x05tag1\
    2\x12\x14\n\x05tag14\x18\x0e\x20\x01(\x03R\x05tag14\x12\x14\n\x05tag15\
    \x18\x0f\x20\x01(\x03R\x05tag15\"\xd7\x02\n\nPayload105\x12\x0e\n\x02f1\
    \x18\x01\x20\x01(\x03R\x02f1\x12\x19\n\x08rider_id\x18\x02\x20\x01(\x05R\
    \x07riderId\x12\x0e\n\x02f3\x18\x03\x20\x01(\x05R\x02f3\x12\x0e\n\x02f4\
    \x18\x04\x20\x01(\x03R\x02f4\x12\x0e\n\x02f5\x18\x05\x20\x01(\x03R\x02f5\
    \x12\x0e\n\x02f6\x18\x06\x20\x01(\x03R\x02f6\x12\x1c\n\tfirstName\x18\
    \x07\x20\x01(\tR\tfirstName\x12\x1a\n\x08lastName\x18\x08\x20\x01(\tR\
    \x08lastName\x12\x0e\n\x02f9\x18\t\x20\x01(\x03R\x02f9\x12\x10\n\x03f11\
    \x18\x0b\x20\x01(\x03R\x03f11\x12\x10\n\x03f12\x18\x0c\x20\x01(\x05R\x03\
    f12\x12\x10\n\x03f13\x18\r\x20\x01(\x05R\x03f13\x12\x10\n\x03f14\x18\x0e\
    \x20\x01(\x05R\x03f14\x12\x10\n\x03f15\x18\x0f\x20\x01(\x05R\x03f15\x12\
    \x10\n\x03f16\x18\x10\x20\x01(\x05R\x03f16\x12\x16\n\x06f7date\x18\x11\
    \x20\x01(\tR\x06f7date\x12\x10\n\x03f19\x18\x13\x20\x01(\x05R\x03f19\"\
    \x85\x02\n\x04Chat\x12\x19\n\x08rider_id\x18\x01\x20\x01(\x05R\x07riderI\
    d\x12\x1e\n\x0bto_rider_id\x18\x02\x20\x01(\x05R\ttoRiderId\x12\x0e\n\
    \x02f3\x18\x03\x20\x01(\x05R\x02f3\x12\x1c\n\tfirstName\x18\x04\x20\x01(\
    \tR\tfirstName\x12\x1a\n\x08lastName\x18\x05\x20\x01(\tR\x08lastName\x12\
    \x18\n\x07message\x18\x06\x20\x01(\tR\x07message\x12\x16\n\x06avatar\x18\
    \x07\x20\x01(\tR\x06avatar\x12\x20\n\x0bcountryCode\x18\x08\x20\x01(\x05\
    R\x0bcountryCode\x12$\n\reventSubgroup\x18\x0b\x20\x01(\x05R\reventSubgr\
    oup\"\x9f\x01\n\x06RideOn\x12\x19\n\x08rider_id\x18\x01\x20\x01(\x05R\
    \x07riderId\x12\x1e\n\x0bto_rider_id\x18\x02\x20\x01(\x05R\ttoRiderId\
    \x12\x1c\n\tfirstName\x18\x03\x20\x01(\tR\tfirstName\x12\x1a\n\x08lastNa\
    me\x18\x04\x20\x01(\tR\x08lastName\x12\x20\n\x0bcountryCode\x18\x05\x20\
    \x01(\x05R\x0bcountryCode\"*\n\x08Payload2\x12\x0e\n\x02f1\x18\x01\x20\
    \x01(\x05R\x02f1\x12\x0e\n\x02f2\x18\x02\x20\x01(\x03R\x02f2\"T\n\x08Tim\
    eSync\x12\x19\n\x08rider_id\x18\x01\x20\x01(\x05R\x07riderId\x12\x1d\n\n\
    world_time\x18\x02\x20\x01(\x03R\tworldTime\x12\x0e\n\x02f3\x18\x03\x20\
    \x01(\x05R\x02f3\"\x0c\n\nPayload110\"\x0c\n\nPayload109\"\xe3\x01\n\x0e\
    EventPositions\x12\x1a\n\x08position\x18\x01\x20\x01(\x05R\x08position\
    \x12e\n\x12eventRiderPosition\x18\x04\x20\x03(\x0b25.ZwiftPacketMonitor.\
    EventPositions.EventRiderPositionR\x12eventRiderPosition\x12\x1d\n\nnum_\
    riders\x18t\x20\x01(\x05R\tnumRiders\x1a/\n\x12EventRiderPosition\x12\
    \x19\n\x08rider_id\x18\x01\x20\x01(\x05R\x07riderId\"\xd2\x04\n\x0eServe\
    rToClient\x12\x12\n\x04tag1\x18\x01\x20\x01(\x05R\x04tag1\x12\x19\n\x08r\
    ider_id\x18\x02\x20\x01(\x05R\x07riderId\x12\x1d\n\nworld_time\x18\x03\
    \x20\x01(\x03R\tworldTime\x12\x14\n\x05seqno\x18\x04\x20\x01(\x05R\x05se\
    qno\x12D\n\rplayer_states\x18\x08\x20\x03(\x0b2\x1f.ZwiftPacketMonitor.P\
    layerStateR\x0cplayerStates\x12G\n\x0eplayer_updates\x18\t\x20\x03(\x0b2\
    \x20.ZwiftPacketMonitor.PlayerUpdateR\rplayerUpdates\x12\x14\n\x05tag11\
    \x18\x0b\x20\x01(\x03R\x05tag11\x12\x19\n\x08local_ip\x18\x0c\x20\x01(\t\
    R\x07localIp\x12\x14\n\x05tag15\x18\x0f\x20\x01(\x05R\x05tag15\x12\x14\n\
    \x05tag17\x18\x11\x20\x01(\x03R\x05tag17\x12\x19\n\x08num_msgs\x18\x12\
    \x20\x01(\x05R\x07numMsgs\x12\x16\n\x06msgnum\x18\x13\x20\x01(\x05R\x06m\
    sgnum\x12K\n\x0fevent_positions\x18\x17\x20\x01(\x0b2\".ZwiftPacketMonit\
    or.EventPositionsR\x0eeventPositions\x127\n\x08servers1\x18\x18\x20\x01(\
    \x0b2\x1b.ZwiftPacketMonitor.Server1R\x08servers1\x127\n\x08servers2\x18\
    \x19\x20\x01(\x0b2\x1b.ZwiftPacketMonitor.Server2R\x08servers2\"o\n\rSer\
    verAddress\x12\x0e\n\x02f1\x18\x01\x20\x01(\x05R\x02f1\x12\x0e\n\x02f2\
    \x18\x02\x20\x01(\x05R\x02f2\x12\x0e\n\x02ip\x18\x03\x20\x01(\tR\x02ip\
    \x12\x0e\n\x02f4\x18\x04\x20\x01(\x05R\x02f4\x12\x0e\n\x02f5\x18\x05\x20\
    \x01(\x07R\x02f5\x12\x0e\n\x02f6\x18\x06\x20\x01(\x07R\x02f6\"}\n\nServe\
    rPool\x12\x0e\n\x02f1\x18\x01\x20\x01(\x05R\x02f1\x12\x0e\n\x02f2\x18\
    \x02\x20\x01(\x05R\x02f2\x12?\n\taddresses\x18\x03\x20\x03(\x0b2!.ZwiftP\
    acketMonitor.ServerAddressR\taddresses\x12\x0e\n\x02f4\x18\x04\x20\x01(\
    \x05R\x02f4\"M\n\x07Server2\x122\n\x04pool\x18\x01\x20\x03(\x0b2\x1e.Zwi\
    ftPacketMonitor.ServerPoolR\x04pool\x12\x0e\n\x02f2\x18\x02\x20\x01(\x05\
    R\x02f2\"z\n\x07Server1\x12?\n\taddresses\x18\x01\x20\x03(\x0b2!.ZwiftPa\
    cketMonitor.ServerAddressR\taddresses\x12\x0e\n\x02f2\x18\x02\x20\x01(\
    \x05R\x02f2\x12\x0e\n\x02f3\x18\x03\x20\x01(\x05R\x02f3\x12\x0e\n\x02f4\
    \x18\x04\x20\x01(\x05R\x02f4\"\xa6\x01\n\x0fWorldAttributes\x12\x19\n\
    \x08world_id\x18\x01\x20\x01(\x05R\x07worldId\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x12\n\x04tag3\x18\x03\x20\x01(\x03R\x04tag3\x12\
    \x12\n\x04tag5\x18\x04\x20\x01(\x03R\x04tag5\x12\x1d\n\nworld_time\x18\
    \x06\x20\x01(\x03R\tworldTime\x12\x1d\n\nclock_time\x18\x07\x20\x01(\x03\
    R\tclockTime\"/\n\x0eWorldAttribute\x12\x1d\n\nworld_time\x18\x02\x20\
    \x01(\x03R\tworldTime\"\xf3\x01\n\x15EventSubgroupProtobuf\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04\
    name\x12\x14\n\x05rules\x18\x08\x20\x01(\x05R\x05rules\x12\x14\n\x05rout\
    e\x18\x16\x20\x01(\x05R\x05route\x12\x12\n\x04laps\x18\x19\x20\x01(\x05R\
    \x04laps\x12$\n\rstartLocation\x18\x1d\x20\x01(\x05R\rstartLocation\x12\
    \x14\n\x05label\x18\x1e\x20\x01(\x05R\x05label\x12\x1a\n\x08paceType\x18\
    \x1f\x20\x01(\x05R\x08paceType\x12\x1e\n\njerseyHash\x18$\x20\x01(\x05R\
    \njerseyHash\"\xde\x02\n\x0fRiderAttributes\x12\x0e\n\x02f2\x18\x02\x20\
    \x01(\x05R\x02f2\x12\x0e\n\x02f3\x18\x03\x20\x01(\x05R\x02f3\x12`\n\x10a\
    ttributeMessage\x18\x04\x20\x01(\x0b24.ZwiftPacketMonitor.RiderAttribute\
    s.AttributeMessageR\x10attributeMessage\x12\x18\n\x07theirId\x18\n\x20\
    \x01(\x05R\x07theirId\x12\x10\n\x03f13\x18\r\x20\x01(\x05R\x03f13\x1a\
    \x9c\x01\n\x10AttributeMessage\x12\x12\n\x04myId\x18\x01\x20\x01(\x05R\
    \x04myId\x12\x18\n\x07theirId\x18\x02\x20\x01(\x05R\x07theirId\x12\x1c\n\
    \tfirstName\x18\x03\x20\x01(\tR\tfirstName\x12\x1a\n\x08lastName\x18\x04\
    \x20\x01(\tR\x08lastName\x12\x20\n\x0bcountryCode\x18\x05\x20\x01(\x05R\
    \x0bcountryCodeJ\xe4b\n\x07\x12\x05\0\0\x9c\x02\x01\n\x08\n\x01\x0c\x12\
    \x03\0\0\x10\n\x08\n\x01\x02\x12\x03\x01\0\x1b\n\n\n\x02\x04\0\x12\x04\
    \x03\09\x01\n\n\n\x03\x04\0\x01\x12\x03\x03\x08\x0e\n\x0b\n\x04\x04\0\
    \x02\0\x12\x03\x04\x04\x11\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x04\x04\t\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x04\n\x0c\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x04\x0f\x10\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x05\x04\x13\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x05\x04\t\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03\x05\n\x0e\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x05\x11\x12\
    \n\x0b\n\x04\x04\0\x02\x02\x12\x03\x06\x04\x14\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03\x06\x04\n\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x06\x0b\x0f\
    \n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x06\x12\x13\n\x0b\n\x04\x04\0\x02\
    \x03\x12\x03\x07\x04\x1b\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x07\x04\n\
    \n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x07\x0b\x16\n\x0c\n\x05\x04\0\x02\
    \x03\x03\x12\x03\x07\x19\x1a\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x08\x04\
    \x19\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x08\x04\t\n\x0c\n\x05\x04\0\
    \x02\x04\x01\x12\x03\x08\n\x14\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x08\
    \x17\x18\n\x0b\n\x04\x04\0\x02\x05\x12\x03\t\x04\x19\n\x0c\n\x05\x04\0\
    \x02\x05\x05\x12\x03\t\x04\x0b\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\t\
    \x0c\x14\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\t\x17\x18\n\x0b\n\x04\x04\
    \0\x02\x06\x12\x03\n\x04\x13\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\n\x04\
    \t\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\n\n\x0e\n\x0c\n\x05\x04\0\x02\
    \x06\x03\x12\x03\n\x11\x12\n\x0c\n\x04\x04\0\x03\0\x12\x04\x0c\x04)\x05\
    \n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\x0c\x0c\x17\n\r\n\x06\x04\0\x03\0\
    \x02\0\x12\x03\r\x08\x15\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03\r\x08\
    \r\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03\r\x0e\x10\n\x0e\n\x07\x04\0\
    \x03\0\x02\0\x03\x12\x03\r\x13\x14\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03\
    \x0e\x08\x18\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03\x0e\x08\x0e\n\
    \x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03\x0e\x0f\x13\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x03\x12\x03\x0e\x16\x17\n\r\n\x06\x04\0\x03\0\x02\x02\x12\
    \x03\x0f\x08\x1f\n\x0e\n\x07\x04\0\x03\0\x02\x02\x05\x12\x03\x0f\x08\x0e\
    \n\x0e\n\x07\x04\0\x03\0\x02\x02\x01\x12\x03\x0f\x0f\x1a\n\x0e\n\x07\x04\
    \0\x03\0\x02\x02\x03\x12\x03\x0f\x1d\x1e\n\r\n\x06\x04\0\x03\0\x02\x03\
    \x12\x03\x10\x08\x16\n\x0e\n\x07\x04\0\x03\0\x02\x03\x05\x12\x03\x10\x08\
    \x0e\n\x0e\n\x07\x04\0\x03\0\x02\x03\x01\x12\x03\x10\x0f\x11\n\x0e\n\x07\
    \x04\0\x03\0\x02\x03\x03\x12\x03\x10\x14\x15\n\r\n\x06\x04\0\x03\0\x02\
    \x04\x12\x03\x11\x08\x15\n\x0e\n\x07\x04\0\x03\0\x02\x04\x05\x12\x03\x11\
    \x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x04\x01\x12\x03\x11\x0e\x10\n\x0e\n\
    \x07\x04\0\x03\0\x02\x04\x03\x12\x03\x11\x13\x14\n\r\n\x06\x04\0\x03\0\
    \x02\x05\x12\x03\x12\x08\x15\n\x0e\n\x07\x04\0\x03\0\x02\x05\x05\x12\x03\
    \x12\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x05\x01\x12\x03\x12\x0e\x10\n\x0e\
    \n\x07\x04\0\x03\0\x02\x05\x03\x12\x03\x12\x13\x14\n\r\n\x06\x04\0\x03\0\
    \x02\x06\x12\x03\x13\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x06\x05\x12\x03\
    \x13\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x06\x01\x12\x03\x13\x0e\x11\n\x0e\
    \n\x07\x04\0\x03\0\x02\x06\x03\x12\x03\x13\x14\x16\n\r\n\x06\x04\0\x03\0\
    \x02\x07\x12\x03\x14\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x07\x05\x12\x03\
    \x14\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x07\x01\x12\x03\x14\x0e\x11\n\x0e\
    \n\x07\x04\0\x03\0\x02\x07\x03\x12\x03\x14\x14\x16\n\r\n\x06\x04\0\x03\0\
    \x02\x08\x12\x03\x15\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x08\x05\x12\x03\
    \x15\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x08\x01\x12\x03\x15\x0e\x11\n\x0e\
    \n\x07\x04\0\x03\0\x02\x08\x03\x12\x03\x15\x14\x16\n\r\n\x06\x04\0\x03\0\
    \x02\t\x12\x03\x16\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\t\x05\x12\x03\x16\
    \x08\r\n\x0e\n\x07\x04\0\x03\0\x02\t\x01\x12\x03\x16\x0e\x11\n\x0e\n\x07\
    \x04\0\x03\0\x02\t\x03\x12\x03\x16\x14\x16\n\r\n\x06\x04\0\x03\0\x02\n\
    \x12\x03\x17\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\n\x05\x12\x03\x17\x08\r\
    \n\x0e\n\x07\x04\0\x03\0\x02\n\x01\x12\x03\x17\x0e\x11\n\x0e\n\x07\x04\0\
    \x03\0\x02\n\x03\x12\x03\x17\x14\x16\n\r\n\x06\x04\0\x03\0\x02\x0b\x12\
    \x03\x18\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x0b\x05\x12\x03\x18\x08\r\n\
    \x0e\n\x07\x04\0\x03\0\x02\x0b\x01\x12\x03\x18\x0e\x11\n\x0e\n\x07\x04\0\
    \x03\0\x02\x0b\x03\x12\x03\x18\x14\x16\n\r\n\x06\x04\0\x03\0\x02\x0c\x12\
    \x03\x19\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x0c\x05\x12\x03\x19\x08\r\n\
    \x0e\n\x07\x04\0\x03\0\x02\x0c\x01\x12\x03\x19\x0e\x11\n\x0e\n\x07\x04\0\
    \x03\0\x02\x0c\x03\x12\x03\x19\x14\x16\n\r\n\x06\x04\0\x03\0\x02\r\x12\
    \x03\x1a\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\r\x05\x12\x03\x1a\x08\r\n\
    \x0e\n\x07\x04\0\x03\0\x02\r\x01\x12\x03\x1a\x0e\x11\n\x0e\n\x07\x04\0\
    \x03\0\x02\r\x03\x12\x03\x1a\x14\x16\n\r\n\x06\x04\0\x03\0\x02\x0e\x12\
    \x03\x1b\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x0e\x05\x12\x03\x1b\x08\r\n\
    \x0e\n\x07\x04\0\x03\0\x02\x0e\x01\x12\x03\x1b\x0e\x11\n\x0e\n\x07\x04\0\
    \x03\0\x02\x0e\x03\x12\x03\x1b\x14\x16\n\r\n\x06\x04\0\x03\0\x02\x0f\x12\
    \x03\x1c\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x0f\x05\x12\x03\x1c\x08\r\n\
    \x0e\n\x07\x04\0\x03\0\x02\x0f\x01\x12\x03\x1c\x0e\x11\n\x0e\n\x07\x04\0\
    \x03\0\x02\x0f\x03\x12\x03\x1c\x14\x16\n\r\n\x06\x04\0\x03\0\x02\x10\x12\
    \x03\x1d\x08\x1e\n\x0e\n\x07\x04\0\x03\0\x02\x10\x05\x12\x03\x1d\x08\x0f\
    \n\x0e\n\x07\x04\0\x03\0\x02\x10\x01\x12\x03\x1d\x10\x18\n\x0e\n\x07\x04\
    \0\x03\0\x02\x10\x03\x12\x03\x1d\x1b\x1d\n\r\n\x06\x04\0\x03\0\x02\x11\
    \x12\x03\x1e\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x11\x05\x12\x03\x1e\x08\
    \r\n\x0e\n\x07\x04\0\x03\0\x02\x11\x01\x12\x03\x1e\x0e\x11\n\x0e\n\x07\
    \x04\0\x03\0\x02\x11\x03\x12\x03\x1e\x14\x16\n\r\n\x06\x04\0\x03\0\x02\
    \x12\x12\x03\x1f\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x12\x05\x12\x03\x1f\
    \x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x12\x01\x12\x03\x1f\x0e\x11\n\x0e\n\
    \x07\x04\0\x03\0\x02\x12\x03\x12\x03\x1f\x14\x16\n\r\n\x06\x04\0\x03\0\
    \x02\x13\x12\x03\x20\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x13\x05\x12\x03\
    \x20\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x13\x01\x12\x03\x20\x0e\x11\n\x0e\
    \n\x07\x04\0\x03\0\x02\x13\x03\x12\x03\x20\x14\x16\n\r\n\x06\x04\0\x03\0\
    \x02\x14\x12\x03!\x08\x17\n\x0e\n\x07\x04\0\x03\0\x02\x14\x05\x12\x03!\
    \x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x14\x01\x12\x03!\x0e\x11\n\x0e\n\x07\
    \x04\0\x03\0\x02\x14\x03\x12\x03!\x14\x16\n\r\n\x06\x04\0\x03\0\x02\x15\
    \x12\x03\"\x08\x19\n\x0e\n\x07\x04\0\x03\0\x02\x15\x05\x12\x03\"\x08\x0f\
    \n\x0e\n\x07\x04\0\x03\0\x02\x15\x01\x12\x03\"\x10\x13\n\x0e\n\x07\x04\0\
    \x03\0\x02\x15\x03\x12\x03\"\x16\x18\n\r\n\x06\x04\0\x03\0\x02\x16\x12\
    \x03#\x08\x19\n\x0e\n\x07\x04\0\x03\0\x02\x16\x05\x12\x03#\x08\x0f\n\x0e\
    \n\x07\x04\0\x03\0\x02\x16\x01\x12\x03#\x10\x13\n\x0e\n\x07\x04\0\x03\0\
    \x02\x16\x03\x12\x03#\x16\x18\n\r\n\x06\x04\0\x03\0\x02\x17\x12\x03$\x08\
    \x1c\n\x0e\n\x07\x04\0\x03\0\x02\x17\x05\x12\x03$\x08\r\n\x0e\n\x07\x04\
    \0\x03\0\x02\x17\x01\x12\x03$\x0e\x16\n\x0e\n\x07\x04\0\x03\0\x02\x17\
    \x03\x12\x03$\x19\x1b\n\r\n\x06\x04\0\x03\0\x02\x18\x12\x03%\x08\x17\n\
    \x0e\n\x07\x04\0\x03\0\x02\x18\x05\x12\x03%\x08\r\n\x0e\n\x07\x04\0\x03\
    \0\x02\x18\x01\x12\x03%\x0e\x11\n\x0e\n\x07\x04\0\x03\0\x02\x18\x03\x12\
    \x03%\x14\x16\n\r\n\x06\x04\0\x03\0\x02\x19\x12\x03&\x08\x17\n\x0e\n\x07\
    \x04\0\x03\0\x02\x19\x05\x12\x03&\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x19\
    \x01\x12\x03&\x0e\x11\n\x0e\n\x07\x04\0\x03\0\x02\x19\x03\x12\x03&\x14\
    \x16\n\r\n\x06\x04\0\x03\0\x02\x1a\x12\x03'\x08\x17\n\x0e\n\x07\x04\0\
    \x03\0\x02\x1a\x05\x12\x03'\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x1a\x01\
    \x12\x03'\x0e\x11\n\x0e\n\x07\x04\0\x03\0\x02\x1a\x03\x12\x03'\x14\x16\n\
    \r\n\x06\x04\0\x03\0\x02\x1b\x12\x03(\x08\x17\n\x0e\n\x07\x04\0\x03\0\
    \x02\x1b\x05\x12\x03(\x08\r\n\x0e\n\x07\x04\0\x03\0\x02\x1b\x01\x12\x03(\
    \x0e\x11\n\x0e\n\x07\x04\0\x03\0\x02\x1b\x03\x12\x03(\x14\x16\n\x0b\n\
    \x04\x04\0\x02\x07\x12\x03*\x04\"\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03*\
    \x04\x0f\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03*\x10\x1c\n\x0c\n\x05\x04\
    \0\x02\x07\x03\x12\x03*\x1f!\n\x0b\n\x04\x04\0\x02\x08\x12\x03+\x04\x1a\
    \n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03+\x04\n\n\x0c\n\x05\x04\0\x02\x08\
    \x01\x12\x03+\x0b\x14\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03+\x17\x19\n\
    \x0b\n\x04\x04\0\x02\t\x12\x03,\x04\x18\n\x0c\n\x05\x04\0\x02\t\x05\x12\
    \x03,\x04\t\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03,\n\x12\n\x0c\n\x05\x04\0\
    \x02\t\x03\x12\x03,\x15\x17\n\x0b\n\x04\x04\0\x02\n\x12\x03-\x04\x13\n\
    \x0c\n\x05\x04\0\x02\n\x05\x12\x03-\x04\t\n\x0c\n\x05\x04\0\x02\n\x01\
    \x12\x03-\n\r\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03-\x10\x12\n\x0b\n\x04\
    \x04\0\x02\x0b\x12\x03.\x04\x13\n\x0c\n\x05\x04\0\x02\x0b\x05\x12\x03.\
    \x04\t\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03.\n\r\n\x0c\n\x05\x04\0\x02\
    \x0b\x03\x12\x03.\x10\x12\n\x0b\n\x04\x04\0\x02\x0c\x12\x03/\x04\x13\n\
    \x0c\n\x05\x04\0\x02\x0c\x05\x12\x03/\x04\t\n\x0c\n\x05\x04\0\x02\x0c\
    \x01\x12\x03/\n\r\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03/\x10\x12\n\x0b\n\
    \x04\x04\0\x02\r\x12\x030\x04\x13\n\x0c\n\x05\x04\0\x02\r\x05\x12\x030\
    \x04\t\n\x0c\n\x05\x04\0\x02\r\x01\x12\x030\n\r\n\x0c\n\x05\x04\0\x02\r\
    \x03\x12\x030\x10\x12\n\x0b\n\x04\x04\0\x02\x0e\x12\x031\x04\x13\n\x0c\n\
    \x05\x04\0\x02\x0e\x05\x12\x031\x04\t\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\
    \x031\n\r\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x031\x10\x12\n\x0b\n\x04\x04\
    \0\x02\x0f\x12\x032\x04\x20\n\x0c\n\x05\x04\0\x02\x0f\x05\x12\x032\x04\t\
    \n\x0c\n\x05\x04\0\x02\x0f\x01\x12\x032\n\x1a\n\x0c\n\x05\x04\0\x02\x0f\
    \x03\x12\x032\x1d\x1f\n\x0b\n\x04\x04\0\x02\x10\x12\x033\x04\x13\n\x0c\n\
    \x05\x04\0\x02\x10\x05\x12\x033\x04\t\n\x0c\n\x05\x04\0\x02\x10\x01\x12\
    \x033\n\r\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x033\x10\x12\n\x0b\n\x04\x04\
    \0\x02\x11\x12\x034\x04\x13\n\x0c\n\x05\x04\0\x02\x11\x05\x12\x034\x04\t\
    \n\x0c\n\x05\x04\0\x02\x11\x01\x12\x034\n\r\n\x0c\n\x05\x04\0\x02\x11\
    \x03\x12\x034\x10\x12\n\x0b\n\x04\x04\0\x02\x12\x12\x035\x04\x13\n\x0c\n\
    \x05\x04\0\x02\x12\x05\x12\x035\x04\t\n\x0c\n\x05\x04\0\x02\x12\x01\x12\
    \x035\n\r\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x035\x10\x12\n\x0b\n\x04\x04\
    \0\x02\x13\x12\x036\x04\x13\n\x0c\n\x05\x04\0\x02\x13\x05\x12\x036\x04\t\
    \n\x0c\n\x05\x04\0\x02\x13\x01\x12\x036\n\r\n\x0c\n\x05\x04\0\x02\x13\
    \x03\x12\x036\x10\x12\n\x0b\n\x04\x04\0\x02\x14\x12\x037\x04\x13\n\x0c\n\
    \x05\x04\0\x02\x14\x05\x12\x037\x04\t\n\x0c\n\x05\x04\0\x02\x14\x01\x12\
    \x037\n\r\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x037\x10\x12\n\x0b\n\x04\x04\
    \0\x02\x15\x12\x038\x04\x13\n\x0c\n\x05\x04\0\x02\x15\x05\x12\x038\x04\t\
    \n\x0c\n\x05\x04\0\x02\x15\x01\x12\x038\n\r\n\x0c\n\x05\x04\0\x02\x15\
    \x03\x12\x038\x10\x12\n\n\n\x02\x04\x01\x12\x04;\0W\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03;\x08\x13\n\x0b\n\x04\x04\x01\x02\0\x12\x03<\x04\x11\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03<\x04\t\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03<\n\x0c\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03<\x0f\x10\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03=\x04\x18\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03=\x04\t\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03=\n\x13\n\x0c\n\
    \x05\x04\x01\x02\x01\x03\x12\x03=\x16\x17\n\x0b\n\x04\x04\x01\x02\x02\
    \x12\x03>\x04\x17\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03>\x04\t\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03>\n\x12\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03>\x15\x16\n\x0b\n\x04\x04\x01\x02\x03\x12\x03?\x04\x17\n\x0c\n\
    \x05\x04\x01\x02\x03\x05\x12\x03?\x04\t\n\x0c\n\x05\x04\x01\x02\x03\x01\
    \x12\x03?\n\x12\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03?\x15\x16\n\x0b\n\
    \x04\x04\x01\x02\x04\x12\x03@\x04\x13\n\x0c\n\x05\x04\x01\x02\x04\x05\
    \x12\x03@\x04\t\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03@\n\x0e\n\x0c\n\
    \x05\x04\x01\x02\x04\x03\x12\x03@\x11\x12\n\x0b\n\x04\x04\x01\x02\x05\
    \x12\x03A\x04\x14\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03A\x04\t\n\x0c\n\
    \x05\x04\x01\x02\x05\x01\x12\x03A\n\x0f\n\x0c\n\x05\x04\x01\x02\x05\x03\
    \x12\x03A\x12\x13\n\x0b\n\x04\x04\x01\x02\x06\x12\x03B\x04\x1b\n\x0c\n\
    \x05\x04\x01\x02\x06\x05\x12\x03B\x04\t\n\x0c\n\x05\x04\x01\x02\x06\x01\
    \x12\x03B\n\x16\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03B\x19\x1a\n\x0b\n\
    \x04\x04\x01\x02\x07\x12\x03C\x04\x19\n\x0c\n\x05\x04\x01\x02\x07\x05\
    \x12\x03C\x04\t\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03C\n\x14\n\x0c\n\
    \x05\x04\x01\x02\x07\x03\x12\x03C\x17\x18\n\x0b\n\x04\x04\x01\x02\x08\
    \x12\x03D\x04\x19\n\x0c\n\x05\x04\x01\x02\x08\x05\x12\x03D\x04\t\n\x0c\n\
    \x05\x04\x01\x02\x08\x01\x12\x03D\n\x13\n\x0c\n\x05\x04\x01\x02\x08\x03\
    \x12\x03D\x16\x18\n\x0b\n\x04\x04\x01\x02\t\x12\x03E\x04\x15\n\x0c\n\x05\
    \x04\x01\x02\t\x05\x12\x03E\x04\t\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03E\
    \n\x0f\n\x0c\n\x05\x04\x01\x02\t\x03\x12\x03E\x12\x14\n\x0b\n\x04\x04\
    \x01\x02\n\x12\x03F\x04\x17\n\x0c\n\x05\x04\x01\x02\n\x05\x12\x03F\x04\t\
    \n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03F\n\x11\n\x0c\n\x05\x04\x01\x02\n\
    \x03\x12\x03F\x14\x16\n\x0b\n\x04\x04\x01\x02\x0b\x12\x03G\x04\x14\n\x0c\
    \n\x05\x04\x01\x02\x0b\x05\x12\x03G\x04\t\n\x0c\n\x05\x04\x01\x02\x0b\
    \x01\x12\x03G\n\x0e\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x03G\x11\x13\n\
    \x0b\n\x04\x04\x01\x02\x0c\x12\x03H\x04\x18\n\x0c\n\x05\x04\x01\x02\x0c\
    \x05\x12\x03H\x04\t\n\x0c\n\x05\x04\x01\x02\x0c\x01\x12\x03H\n\x12\n\x0c\
    \n\x05\x04\x01\x02\x0c\x03\x12\x03H\x15\x17\n\x0b\n\x04\x04\x01\x02\r\
    \x12\x03I\x04\x14\n\x0c\n\x05\x04\x01\x02\r\x05\x12\x03I\x04\t\n\x0c\n\
    \x05\x04\x01\x02\r\x01\x12\x03I\n\x0e\n\x0c\n\x05\x04\x01\x02\r\x03\x12\
    \x03I\x11\x13\n\x0b\n\x04\x04\x01\x02\x0e\x12\x03J\x04\x13\n\x0c\n\x05\
    \x04\x01\x02\x0e\x05\x12\x03J\x04\t\n\x0c\n\x05\x04\x01\x02\x0e\x01\x12\
    \x03J\n\r\n\x0c\n\x05\x04\x01\x02\x0e\x03\x12\x03J\x10\x12\n\x0b\n\x04\
    \x04\x01\x02\x0f\x12\x03K\x04\x13\n\x0c\n\x05\x04\x01\x02\x0f\x05\x12\
    \x03K\x04\t\n\x0c\n\x05\x04\x01\x02\x0f\x01\x12\x03K\n\r\n\x0c\n\x05\x04\
    \x01\x02\x0f\x03\x12\x03K\x10\x12\n\x0b\n\x04\x04\x01\x02\x10\x12\x03L\
    \x04\x18\n\x0c\n\x05\x04\x01\x02\x10\x05\x12\x03L\x04\t\n\x0c\n\x05\x04\
    \x01\x02\x10\x01\x12\x03L\n\x12\n\x0c\n\x05\x04\x01\x02\x10\x03\x12\x03L\
    \x15\x17\n\x0b\n\x04\x04\x01\x02\x11\x12\x03M\x04\x1f\n\x0c\n\x05\x04\
    \x01\x02\x11\x05\x12\x03M\x04\t\n\x0c\n\x05\x04\x01\x02\x11\x01\x12\x03M\
    \n\x19\n\x0c\n\x05\x04\x01\x02\x11\x03\x12\x03M\x1c\x1e\n\x0b\n\x04\x04\
    \x01\x02\x12\x12\x03N\x04\x1c\n\x0c\n\x05\x04\x01\x02\x12\x05\x12\x03N\
    \x04\t\n\x0c\n\x05\x04\x01\x02\x12\x01\x12\x03N\n\x16\n\x0c\n\x05\x04\
    \x01\x02\x12\x03\x12\x03N\x19\x1b\n\x0b\n\x04\x04\x01\x02\x13\x12\x03O\
    \x04\x18\n\x0c\n\x05\x04\x01\x02\x13\x05\x12\x03O\x04\t\n\x0c\n\x05\x04\
    \x01\x02\x13\x01\x12\x03O\n\x12\n\x0c\n\x05\x04\x01\x02\x13\x03\x12\x03O\
    \x15\x17\n\x0b\n\x04\x04\x01\x02\x14\x12\x03P\x04\x11\n\x0c\n\x05\x04\
    \x01\x02\x14\x05\x12\x03P\x04\t\n\x0c\n\x05\x04\x01\x02\x14\x01\x12\x03P\
    \n\x0b\n\x0c\n\x05\x04\x01\x02\x14\x03\x12\x03P\x0e\x10\n\x0b\n\x04\x04\
    \x01\x02\x15\x12\x03Q\x04\x18\n\x0c\n\x05\x04\x01\x02\x15\x05\x12\x03Q\
    \x04\t\n\x0c\n\x05\x04\x01\x02\x15\x01\x12\x03Q\n\x12\n\x0c\n\x05\x04\
    \x01\x02\x15\x03\x12\x03Q\x15\x17\n\x0b\n\x04\x04\x01\x02\x16\x12\x03R\
    \x04\x11\n\x0c\n\x05\x04\x01\x02\x16\x05\x12\x03R\x04\t\n\x0c\n\x05\x04\
    \x01\x02\x16\x01\x12\x03R\n\x0b\n\x0c\n\x05\x04\x01\x02\x16\x03\x12\x03R\
    \x0e\x10\n\x0b\n\x04\x04\x01\x02\x17\x12\x03S\x04\x1f\n\x0c\n\x05\x04\
    \x01\x02\x17\x05\x12\x03S\x04\t\n\x0c\n\x05\x04\x01\x02\x17\x01\x12\x03S\
    \n\x19\n\x0c\n\x05\x04\x01\x02\x17\x03\x12\x03S\x1c\x1e\n\x0b\n\x04\x04\
    \x01\x02\x18\x12\x03T\x04\x17\n\x0c\n\x05\x04\x01\x02\x18\x05\x12\x03T\
    \x04\t\n\x0c\n\x05\x04\x01\x02\x18\x01\x12\x03T\n\x11\n\x0c\n\x05\x04\
    \x01\x02\x18\x03\x12\x03T\x14\x16\n\x0b\n\x04\x04\x01\x02\x19\x12\x03U\
    \x04\x15\n\x0c\n\x05\x04\x01\x02\x19\x05\x12\x03U\x04\t\n\x0c\n\x05\x04\
    \x01\x02\x19\x01\x12\x03U\n\x0f\n\x0c\n\x05\x04\x01\x02\x19\x03\x12\x03U\
    \x12\x14\n>\n\x04\x04\x01\x02\x1a\x12\x03V\x04\x13\"1\x20actual\x20dista\
    nce\x20moved\x20included\x20lateral\x20movement\n\n\x0c\n\x05\x04\x01\
    \x02\x1a\x05\x12\x03V\x04\t\n\x0c\n\x05\x04\x01\x02\x1a\x01\x12\x03V\n\r\
    \n\x0c\n\x05\x04\x01\x02\x1a\x03\x12\x03V\x10\x12\n\n\n\x02\x04\x02\x12\
    \x04Y\0d\x01\n\n\n\x03\x04\x02\x01\x12\x03Y\x08\x16\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x03Z\x04\x18\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03Z\x04\t\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03Z\n\x13\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03Z\x16\x17\n\x0b\n\x04\x04\x02\x02\x01\x12\x03[\x04\x17\n\x0c\
    \n\x05\x04\x02\x02\x01\x05\x12\x03[\x04\t\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03[\n\x12\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03[\x15\x16\n\
    \x0b\n\x04\x04\x02\x02\x02\x12\x03\\\x04\x19\n\x0c\n\x05\x04\x02\x02\x02\
    \x05\x12\x03\\\x04\t\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\\\n\x14\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\\\x17\x18\n\x0b\n\x04\x04\x02\x02\
    \x03\x12\x03]\x04\x14\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03]\x04\t\n\
    \x0c\n\x05\x04\x02\x02\x03\x01\x12\x03]\n\x0f\n\x0c\n\x05\x04\x02\x02\
    \x03\x03\x12\x03]\x12\x13\n\x0b\n\x04\x04\x02\x02\x04\x12\x03^\x04\x1a\n\
    \x0c\n\x05\x04\x02\x02\x04\x06\x12\x03^\x04\x0f\n\x0c\n\x05\x04\x02\x02\
    \x04\x01\x12\x03^\x10\x15\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03^\x18\
    \x19\n\x0b\n\x04\x04\x02\x02\x05\x12\x03_\x04\x13\n\x0c\n\x05\x04\x02\
    \x02\x05\x05\x12\x03_\x04\t\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03_\n\
    \x0e\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03_\x11\x12\n\x0b\n\x04\x04\
    \x02\x02\x06\x12\x03`\x04\x13\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x03`\
    \x04\t\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03`\n\x0e\n\x0c\n\x05\x04\
    \x02\x02\x06\x03\x12\x03`\x11\x12\n\x0b\n\x04\x04\x02\x02\x07\x12\x03a\
    \x04\x1b\n\x0c\n\x05\x04\x02\x02\x07\x05\x12\x03a\x04\t\n\x0c\n\x05\x04\
    \x02\x02\x07\x01\x12\x03a\n\x15\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03a\
    \x18\x1a\n\x0b\n\x04\x04\x02\x02\x08\x12\x03b\x04\x15\n\x0c\n\x05\x04\
    \x02\x02\x08\x05\x12\x03b\x04\t\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03b\
    \n\x0f\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\x03b\x12\x14\n\x0b\n\x04\x04\
    \x02\x02\t\x12\x03c\x04\"\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03c\x04\t\n\
    \x0c\n\x05\x04\x02\x02\t\x01\x12\x03c\n\x1c\n\x0c\n\x05\x04\x02\x02\t\
    \x03\x12\x03c\x1f!\nK\n\x02\x04\x03\x12\x04f\0j\x01\"?\x20string\x20firs\
    tName=7;\n\x20string\x20lastName=8;\n\x20string\x20timestamp=17;\n\n\n\n\
    \x03\x04\x03\x01\x12\x03f\x08\x17\n4\n\x02\x04\x04\x12\x04l\0o\x01\"(\
    \x20int64\x20tag1=1;\n\x20UnknownMessage1\x20tag4=4;\n\n\n\n\x03\x04\x04\
    \x01\x12\x03l\x08\x16\n\x0b\n\x02\x04\x05\x12\x05r\0\x80\x01\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03r\x08\x14\n\x0b\n\x04\x04\x05\x02\0\x12\x03s\x04\
    \x13\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03s\x04\t\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03s\n\x0e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03s\x11\x12\
    \n\x0b\n\x04\x04\x05\x02\x01\x12\x03t\x04\x13\n\x0c\n\x05\x04\x05\x02\
    \x01\x05\x12\x03t\x04\t\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03t\n\x0e\n\
    \x0c\n\x05\x04\x05\x02\x01\x03\x12\x03t\x11\x12\n\x0b\n\x04\x04\x05\x02\
    \x02\x12\x03u\x04\x13\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03u\x04\t\n\
    \x0c\n\x05\x04\x05\x02\x02\x01\x12\x03u\n\x0e\n\x0c\n\x05\x04\x05\x02\
    \x02\x03\x12\x03u\x11\x12\n\x0b\n\x04\x04\x05\x02\x03\x12\x03v\x04\x16\n\
    \x0c\n\x05\x04\x05\x02\x03\x05\x12\x03v\x04\t\n\x0c\n\x05\x04\x05\x02\
    \x03\x01\x12\x03v\n\x11\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03v\x14\x15\
    \n\x0b\n\x04\x04\x05\x02\x04\x12\x03w\x04\x13\n\x0c\n\x05\x04\x05\x02\
    \x04\x05\x12\x03w\x04\t\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03w\n\x0e\n\
    \x0c\n\x05\x04\x05\x02\x04\x03\x12\x03w\x11\x12\n\x0b\n\x04\x04\x05\x02\
    \x05\x12\x03x\x04\x13\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x03x\x04\t\n\
    \x0c\n\x05\x04\x05\x02\x05\x01\x12\x03x\n\x0e\n\x0c\n\x05\x04\x05\x02\
    \x05\x03\x12\x03x\x11\x12\n\x0b\n\x04\x04\x05\x02\x06\x12\x03y\x04\x13\n\
    \x0c\n\x05\x04\x05\x02\x06\x05\x12\x03y\x04\t\n\x0c\n\x05\x04\x05\x02\
    \x06\x01\x12\x03y\n\x0e\n\x0c\n\x05\x04\x05\x02\x06\x03\x12\x03y\x11\x12\
    \n\x0b\n\x04\x04\x05\x02\x07\x12\x03z\x04\x13\n\x0c\n\x05\x04\x05\x02\
    \x07\x05\x12\x03z\x04\t\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03z\n\x0e\n\
    \x0c\n\x05\x04\x05\x02\x07\x03\x12\x03z\x11\x12\n\x0b\n\x04\x04\x05\x02\
    \x08\x12\x03{\x04\x13\n\x0c\n\x05\x04\x05\x02\x08\x05\x12\x03{\x04\t\n\
    \x0c\n\x05\x04\x05\x02\x08\x01\x12\x03{\n\x0e\n\x0c\n\x05\x04\x05\x02\
    \x08\x03\x12\x03{\x11\x12\n\x0b\n\x04\x04\x05\x02\t\x12\x03|\x04\x15\n\
    \x0c\n\x05\x04\x05\x02\t\x05\x12\x03|\x04\t\n\x0c\n\x05\x04\x05\x02\t\
    \x01\x12\x03|\n\x0f\n\x0c\n\x05\x04\x05\x02\t\x03\x12\x03|\x12\x14\n\x0b\
    \n\x04\x04\x05\x02\n\x12\x03}\x04\x15\n\x0c\n\x05\x04\x05\x02\n\x05\x12\
    \x03}\x04\t\n\x0c\n\x05\x04\x05\x02\n\x01\x12\x03}\n\x0f\n\x0c\n\x05\x04\
    \x05\x02\n\x03\x12\x03}\x12\x14\n\x0b\n\x04\x04\x05\x02\x0b\x12\x03~\x04\
    \x15\n\x0c\n\x05\x04\x05\x02\x0b\x05\x12\x03~\x04\t\n\x0c\n\x05\x04\x05\
    \x02\x0b\x01\x12\x03~\n\x0f\n\x0c\n\x05\x04\x05\x02\x0b\x03\x12\x03~\x12\
    \x14\n\x0b\n\x04\x04\x05\x02\x0c\x12\x03\x7f\x04\x15\n\x0c\n\x05\x04\x05\
    \x02\x0c\x05\x12\x03\x7f\x04\t\n\x0c\n\x05\x04\x05\x02\x0c\x01\x12\x03\
    \x7f\n\x0f\n\x0c\n\x05\x04\x05\x02\x0c\x03\x12\x03\x7f\x12\x14\n&\n\x02\
    \x04\x06\x12\x06\x82\x01\0\x94\x01\x01\"\x18\x20player\x20entered\x20wor\
    ld\x20?\n\n\x0b\n\x03\x04\x06\x01\x12\x04\x82\x01\x08\x12\n\x0c\n\x04\
    \x04\x06\x02\0\x12\x04\x83\x01\x04\x11\n\r\n\x05\x04\x06\x02\0\x05\x12\
    \x04\x83\x01\x04\t\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x83\x01\n\x0c\n\r\
    \n\x05\x04\x06\x02\0\x03\x12\x04\x83\x01\x0f\x10\n\x0c\n\x04\x04\x06\x02\
    \x01\x12\x04\x84\x01\x04\x17\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x84\
    \x01\x04\t\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x84\x01\n\x12\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\x84\x01\x15\x16\n\x0c\n\x04\x04\x06\x02\x02\
    \x12\x04\x85\x01\x04\x11\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\x85\x01\
    \x04\t\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\x85\x01\n\x0c\n\r\n\x05\x04\
    \x06\x02\x02\x03\x12\x04\x85\x01\x0f\x10\n\x16\n\x04\x04\x06\x02\x03\x12\
    \x04\x86\x01\x04\x11\"\x08\x20int32?\n\n\r\n\x05\x04\x06\x02\x03\x05\x12\
    \x04\x86\x01\x04\t\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x86\x01\n\x0c\n\
    \r\n\x05\x04\x06\x02\x03\x03\x12\x04\x86\x01\x0f\x10\n\x0c\n\x04\x04\x06\
    \x02\x04\x12\x04\x87\x01\x04\x11\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\
    \x87\x01\x04\t\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\x87\x01\n\x0c\n\r\n\
    \x05\x04\x06\x02\x04\x03\x12\x04\x87\x01\x0f\x10\n\x16\n\x04\x04\x06\x02\
    \x05\x12\x04\x88\x01\x04\x11\"\x08\x20int32?\n\n\r\n\x05\x04\x06\x02\x05\
    \x05\x12\x04\x88\x01\x04\t\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\x88\x01\
    \n\x0c\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\x88\x01\x0f\x10\n\x0c\n\x04\
    \x04\x06\x02\x06\x12\x04\x89\x01\x04\x19\n\r\n\x05\x04\x06\x02\x06\x05\
    \x12\x04\x89\x01\x04\n\n\r\n\x05\x04\x06\x02\x06\x01\x12\x04\x89\x01\x0b\
    \x14\n\r\n\x05\x04\x06\x02\x06\x03\x12\x04\x89\x01\x17\x18\n\x0c\n\x04\
    \x04\x06\x02\x07\x12\x04\x8a\x01\x04\x18\n\r\n\x05\x04\x06\x02\x07\x05\
    \x12\x04\x8a\x01\x04\n\n\r\n\x05\x04\x06\x02\x07\x01\x12\x04\x8a\x01\x0b\
    \x13\n\r\n\x05\x04\x06\x02\x07\x03\x12\x04\x8a\x01\x16\x17\n\x0c\n\x04\
    \x04\x06\x02\x08\x12\x04\x8b\x01\x04\x11\n\r\n\x05\x04\x06\x02\x08\x05\
    \x12\x04\x8b\x01\x04\t\n\r\n\x05\x04\x06\x02\x08\x01\x12\x04\x8b\x01\n\
    \x0c\n\r\n\x05\x04\x06\x02\x08\x03\x12\x04\x8b\x01\x0f\x10\n\x0c\n\x04\
    \x04\x06\x02\t\x12\x04\x8c\x01\x04\x13\n\r\n\x05\x04\x06\x02\t\x05\x12\
    \x04\x8c\x01\x04\t\n\r\n\x05\x04\x06\x02\t\x01\x12\x04\x8c\x01\n\r\n\r\n\
    \x05\x04\x06\x02\t\x03\x12\x04\x8c\x01\x10\x12\n\x0c\n\x04\x04\x06\x02\n\
    \x12\x04\x8d\x01\x04\x13\n\r\n\x05\x04\x06\x02\n\x05\x12\x04\x8d\x01\x04\
    \t\n\r\n\x05\x04\x06\x02\n\x01\x12\x04\x8d\x01\n\r\n\r\n\x05\x04\x06\x02\
    \n\x03\x12\x04\x8d\x01\x10\x12\n\x0c\n\x04\x04\x06\x02\x0b\x12\x04\x8e\
    \x01\x04\x13\n\r\n\x05\x04\x06\x02\x0b\x05\x12\x04\x8e\x01\x04\t\n\r\n\
    \x05\x04\x06\x02\x0b\x01\x12\x04\x8e\x01\n\r\n\r\n\x05\x04\x06\x02\x0b\
    \x03\x12\x04\x8e\x01\x10\x12\n\x0c\n\x04\x04\x06\x02\x0c\x12\x04\x8f\x01\
    \x04\x13\n\r\n\x05\x04\x06\x02\x0c\x05\x12\x04\x8f\x01\x04\t\n\r\n\x05\
    \x04\x06\x02\x0c\x01\x12\x04\x8f\x01\n\r\n\r\n\x05\x04\x06\x02\x0c\x03\
    \x12\x04\x8f\x01\x10\x12\n\x0c\n\x04\x04\x06\x02\r\x12\x04\x90\x01\x04\
    \x13\n\r\n\x05\x04\x06\x02\r\x05\x12\x04\x90\x01\x04\t\n\r\n\x05\x04\x06\
    \x02\r\x01\x12\x04\x90\x01\n\r\n\r\n\x05\x04\x06\x02\r\x03\x12\x04\x90\
    \x01\x10\x12\n\x0c\n\x04\x04\x06\x02\x0e\x12\x04\x91\x01\x04\x13\n\r\n\
    \x05\x04\x06\x02\x0e\x05\x12\x04\x91\x01\x04\t\n\r\n\x05\x04\x06\x02\x0e\
    \x01\x12\x04\x91\x01\n\r\n\r\n\x05\x04\x06\x02\x0e\x03\x12\x04\x91\x01\
    \x10\x12\n\x0c\n\x04\x04\x06\x02\x0f\x12\x04\x92\x01\x04\x17\n\r\n\x05\
    \x04\x06\x02\x0f\x05\x12\x04\x92\x01\x04\n\n\r\n\x05\x04\x06\x02\x0f\x01\
    \x12\x04\x92\x01\x0b\x11\n\r\n\x05\x04\x06\x02\x0f\x03\x12\x04\x92\x01\
    \x14\x16\n\x0c\n\x04\x04\x06\x02\x10\x12\x04\x93\x01\x04\x13\n\r\n\x05\
    \x04\x06\x02\x10\x05\x12\x04\x93\x01\x04\t\n\r\n\x05\x04\x06\x02\x10\x01\
    \x12\x04\x93\x01\n\r\n\r\n\x05\x04\x06\x02\x10\x03\x12\x04\x93\x01\x10\
    \x12\n\x0c\n\x02\x04\x07\x12\x06\x96\x01\0\xa0\x01\x01\n\x0b\n\x03\x04\
    \x07\x01\x12\x04\x96\x01\x08\x0c\n\x0c\n\x04\x04\x07\x02\0\x12\x04\x97\
    \x01\x04\x17\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x97\x01\x04\t\n\r\n\x05\
    \x04\x07\x02\0\x01\x12\x04\x97\x01\n\x12\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\x97\x01\x15\x16\n#\n\x04\x04\x07\x02\x01\x12\x04\x98\x01\x04\x1a\"\
    \x15\x200\x20if\x20public\x20message\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\
    \x04\x98\x01\x04\t\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x98\x01\n\x15\n\
    \r\n\x05\x04\x07\x02\x01\x03\x12\x04\x98\x01\x18\x19\n\x20\n\x04\x04\x07\
    \x02\x02\x12\x04\x99\x01\x04\x11\"\x12\x20always\x20value\x201\x20?\n\n\
    \r\n\x05\x04\x07\x02\x02\x05\x12\x04\x99\x01\x04\t\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\x99\x01\n\x0c\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\x99\
    \x01\x0f\x10\n\x0c\n\x04\x04\x07\x02\x03\x12\x04\x9a\x01\x04\x19\n\r\n\
    \x05\x04\x07\x02\x03\x05\x12\x04\x9a\x01\x04\n\n\r\n\x05\x04\x07\x02\x03\
    \x01\x12\x04\x9a\x01\x0b\x14\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\x9a\
    \x01\x17\x18\n\x0c\n\x04\x04\x07\x02\x04\x12\x04\x9b\x01\x04\x18\n\r\n\
    \x05\x04\x07\x02\x04\x05\x12\x04\x9b\x01\x04\n\n\r\n\x05\x04\x07\x02\x04\
    \x01\x12\x04\x9b\x01\x0b\x13\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\x9b\
    \x01\x16\x17\n\x0c\n\x04\x04\x07\x02\x05\x12\x04\x9c\x01\x04\x17\n\r\n\
    \x05\x04\x07\x02\x05\x05\x12\x04\x9c\x01\x04\n\n\r\n\x05\x04\x07\x02\x05\
    \x01\x12\x04\x9c\x01\x0b\x12\n\r\n\x05\x04\x07\x02\x05\x03\x12\x04\x9c\
    \x01\x15\x16\n\x0c\n\x04\x04\x07\x02\x06\x12\x04\x9d\x01\x04\x16\n\r\n\
    \x05\x04\x07\x02\x06\x05\x12\x04\x9d\x01\x04\n\n\r\n\x05\x04\x07\x02\x06\
    \x01\x12\x04\x9d\x01\x0b\x11\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\x9d\
    \x01\x14\x15\n\x0c\n\x04\x04\x07\x02\x07\x12\x04\x9e\x01\x04\x1a\n\r\n\
    \x05\x04\x07\x02\x07\x05\x12\x04\x9e\x01\x04\t\n\r\n\x05\x04\x07\x02\x07\
    \x01\x12\x04\x9e\x01\n\x15\n\r\n\x05\x04\x07\x02\x07\x03\x12\x04\x9e\x01\
    \x18\x19\n\x0c\n\x04\x04\x07\x02\x08\x12\x04\x9f\x01\x04\x1d\n\r\n\x05\
    \x04\x07\x02\x08\x05\x12\x04\x9f\x01\x04\t\n\r\n\x05\x04\x07\x02\x08\x01\
    \x12\x04\x9f\x01\n\x17\n\r\n\x05\x04\x07\x02\x08\x03\x12\x04\x9f\x01\x1a\
    \x1c\n\x0c\n\x02\x04\x08\x12\x06\xa2\x01\0\xa8\x01\x01\n\x0b\n\x03\x04\
    \x08\x01\x12\x04\xa2\x01\x08\x0e\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xa3\
    \x01\x04\x17\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xa3\x01\x04\t\n\r\n\x05\
    \x04\x08\x02\0\x01\x12\x04\xa3\x01\n\x12\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\xa3\x01\x15\x16\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xa4\x01\x04\x1a\
    \n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xa4\x01\x04\t\n\r\n\x05\x04\x08\
    \x02\x01\x01\x12\x04\xa4\x01\n\x15\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\
    \xa4\x01\x18\x19\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\xa5\x01\x04\x19\n\r\
    \n\x05\x04\x08\x02\x02\x05\x12\x04\xa5\x01\x04\n\n\r\n\x05\x04\x08\x02\
    \x02\x01\x12\x04\xa5\x01\x0b\x14\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\
    \xa5\x01\x17\x18\n\x0c\n\x04\x04\x08\x02\x03\x12\x04\xa6\x01\x04\x18\n\r\
    \n\x05\x04\x08\x02\x03\x05\x12\x04\xa6\x01\x04\n\n\r\n\x05\x04\x08\x02\
    \x03\x01\x12\x04\xa6\x01\x0b\x13\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\
    \xa6\x01\x16\x17\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\xa7\x01\x04\x1a\n\r\
    \n\x05\x04\x08\x02\x04\x05\x12\x04\xa7\x01\x04\t\n\r\n\x05\x04\x08\x02\
    \x04\x01\x12\x04\xa7\x01\n\x15\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xa7\
    \x01\x18\x19\n\x0c\n\x02\x04\t\x12\x06\xaa\x01\0\xad\x01\x01\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xaa\x01\x08\x10\n\x0c\n\x04\x04\t\x02\0\x12\x04\xab\
    \x01\x04\x11\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xab\x01\x04\t\n\r\n\x05\
    \x04\t\x02\0\x01\x12\x04\xab\x01\n\x0c\n\r\n\x05\x04\t\x02\0\x03\x12\x04\
    \xab\x01\x0f\x10\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xac\x01\x04\x11\n\r\n\
    \x05\x04\t\x02\x01\x05\x12\x04\xac\x01\x04\t\n\r\n\x05\x04\t\x02\x01\x01\
    \x12\x04\xac\x01\n\x0c\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xac\x01\x0f\
    \x10\n\x0c\n\x02\x04\n\x12\x06\xaf\x01\0\xb3\x01\x01\n\x0b\n\x03\x04\n\
    \x01\x12\x04\xaf\x01\x08\x10\n\x0c\n\x04\x04\n\x02\0\x12\x04\xb0\x01\x04\
    \x17\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xb0\x01\x04\t\n\r\n\x05\x04\n\x02\
    \0\x01\x12\x04\xb0\x01\n\x12\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb0\x01\
    \x15\x16\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xb1\x01\x04\x19\n\r\n\x05\x04\
    \n\x02\x01\x05\x12\x04\xb1\x01\x04\t\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\
    \xb1\x01\n\x14\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xb1\x01\x17\x18\n\x0c\
    \n\x04\x04\n\x02\x02\x12\x04\xb2\x01\x04\x11\n\r\n\x05\x04\n\x02\x02\x05\
    \x12\x04\xb2\x01\x04\t\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xb2\x01\n\x0c\
    \n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xb2\x01\x0f\x10\n'\n\x02\x04\x0b\
    \x12\x06\xb5\x01\0\xb7\x01\x01\"\x19\x20format\x20to\x20be\x20determined\
    \n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb5\x01\x08\x12\n'\n\x02\x04\x0c\x12\
    \x06\xb9\x01\0\xbb\x01\x01\"\x19\x20format\x20to\x20be\x20determined\n\n\
    \x0b\n\x03\x04\x0c\x01\x12\x04\xb9\x01\x08\x12\n\x0c\n\x02\x04\r\x12\x06\
    \xbe\x01\0\xc6\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xbe\x01\x08\x16\n\
    \x0c\n\x04\x04\r\x02\0\x12\x04\xbf\x01\x04\x17\n\r\n\x05\x04\r\x02\0\x05\
    \x12\x04\xbf\x01\x04\t\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xbf\x01\n\x12\n\
    \r\n\x05\x04\r\x02\0\x03\x12\x04\xbf\x01\x15\x16\n\x0e\n\x04\x04\r\x03\0\
    \x12\x06\xc0\x01\x04\xc3\x01\x05\n\r\n\x05\x04\r\x03\0\x01\x12\x04\xc0\
    \x01\x0c\x1e\n1\n\x06\x04\r\x03\0\x02\0\x12\x04\xc1\x01\x08\x1b\"!\x20??\
    \x20float\x20distance_covered\x20=\x202;\x20\n\n\x0f\n\x07\x04\r\x03\0\
    \x02\0\x05\x12\x04\xc1\x01\x08\r\n\x0f\n\x07\x04\r\x03\0\x02\0\x01\x12\
    \x04\xc1\x01\x0e\x16\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\x04\xc1\x01\
    \x19\x1a\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc4\x01\x047\n\r\n\x05\x04\r\
    \x02\x01\x04\x12\x04\xc4\x01\x04\x0c\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\
    \xc4\x01\r\x1f\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc4\x01\x202\n\r\n\
    \x05\x04\r\x02\x01\x03\x12\x04\xc4\x0156\n\x0c\n\x04\x04\r\x02\x02\x12\
    \x04\xc5\x01\x04\x1b\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xc5\x01\x04\t\n\
    \r\n\x05\x04\r\x02\x02\x01\x12\x04\xc5\x01\n\x14\n\r\n\x05\x04\r\x02\x02\
    \x03\x12\x04\xc5\x01\x17\x1a\n\x0c\n\x02\x04\x0e\x12\x06\xc8\x01\0\xd8\
    \x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc8\x01\x08\x16\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\xc9\x01\x04\x13\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\
    \xc9\x01\x04\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xc9\x01\n\x0e\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\xc9\x01\x11\x12\n\x0c\n\x04\x04\x0e\x02\
    \x01\x12\x04\xca\x01\x04\x17\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xca\
    \x01\x04\t\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xca\x01\n\x12\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\xca\x01\x15\x16\n\x0c\n\x04\x04\x0e\x02\x02\
    \x12\x04\xcb\x01\x04\x19\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xcb\x01\
    \x04\t\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xcb\x01\n\x14\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\xcb\x01\x17\x18\n\x0c\n\x04\x04\x0e\x02\x03\x12\
    \x04\xcc\x01\x04\x14\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xcc\x01\x04\t\
    \n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xcc\x01\n\x0f\n\r\n\x05\x04\x0e\
    \x02\x03\x03\x12\x04\xcc\x01\x12\x13\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\
    \xcd\x01\x04+\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\xcd\x01\x04\x0c\n\r\
    \n\x05\x04\x0e\x02\x04\x06\x12\x04\xcd\x01\r\x18\n\r\n\x05\x04\x0e\x02\
    \x04\x01\x12\x04\xcd\x01\x19&\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xcd\
    \x01)*\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\xce\x01\x04-\n\r\n\x05\x04\
    \x0e\x02\x05\x04\x12\x04\xce\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x05\x06\
    \x12\x04\xce\x01\r\x19\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xce\x01\x1a\
    (\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\xce\x01+,\n\x0c\n\x04\x04\x0e\
    \x02\x06\x12\x04\xcf\x01\x04\x15\n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\
    \xcf\x01\x04\t\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\xcf\x01\n\x0f\n\r\n\
    \x05\x04\x0e\x02\x06\x03\x12\x04\xcf\x01\x12\x14\n\x0c\n\x04\x04\x0e\x02\
    \x07\x12\x04\xd0\x01\x04\x19\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\xd0\
    \x01\x04\n\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xd0\x01\x0b\x13\n\r\n\
    \x05\x04\x0e\x02\x07\x03\x12\x04\xd0\x01\x16\x18\n\x0c\n\x04\x04\x0e\x02\
    \x08\x12\x04\xd1\x01\x04\x15\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\xd1\
    \x01\x04\t\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xd1\x01\n\x0f\n\r\n\x05\
    \x04\x0e\x02\x08\x03\x12\x04\xd1\x01\x12\x14\n\x0c\n\x04\x04\x0e\x02\t\
    \x12\x04\xd2\x01\x04\x15\n\r\n\x05\x04\x0e\x02\t\x05\x12\x04\xd2\x01\x04\
    \t\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\xd2\x01\n\x0f\n\r\n\x05\x04\x0e\
    \x02\t\x03\x12\x04\xd2\x01\x12\x14\n\x0c\n\x04\x04\x0e\x02\n\x12\x04\xd3\
    \x01\x04\x18\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\xd3\x01\x04\t\n\r\n\x05\
    \x04\x0e\x02\n\x01\x12\x04\xd3\x01\n\x12\n\r\n\x05\x04\x0e\x02\n\x03\x12\
    \x04\xd3\x01\x15\x17\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\xd4\x01\x04\x16\
    \n\r\n\x05\x04\x0e\x02\x0b\x05\x12\x04\xd4\x01\x04\t\n\r\n\x05\x04\x0e\
    \x02\x0b\x01\x12\x04\xd4\x01\n\x10\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\
    \xd4\x01\x13\x15\n\x0c\n\x04\x04\x0e\x02\x0c\x12\x04\xd5\x01\x04(\n\r\n\
    \x05\x04\x0e\x02\x0c\x06\x12\x04\xd5\x01\x04\x12\n\r\n\x05\x04\x0e\x02\
    \x0c\x01\x12\x04\xd5\x01\x13\"\n\r\n\x05\x04\x0e\x02\x0c\x03\x12\x04\xd5\
    \x01%'\n\x0c\n\x04\x04\x0e\x02\r\x12\x04\xd6\x01\x04\x1a\n\r\n\x05\x04\
    \x0e\x02\r\x06\x12\x04\xd6\x01\x04\x0b\n\r\n\x05\x04\x0e\x02\r\x01\x12\
    \x04\xd6\x01\x0c\x14\n\r\n\x05\x04\x0e\x02\r\x03\x12\x04\xd6\x01\x17\x19\
    \n\x0c\n\x04\x04\x0e\x02\x0e\x12\x04\xd7\x01\x04\x1a\n\r\n\x05\x04\x0e\
    \x02\x0e\x06\x12\x04\xd7\x01\x04\x0b\n\r\n\x05\x04\x0e\x02\x0e\x01\x12\
    \x04\xd7\x01\x0c\x14\n\r\n\x05\x04\x0e\x02\x0e\x03\x12\x04\xd7\x01\x17\
    \x19\n\x0c\n\x02\x04\x0f\x12\x06\xda\x01\0\xe1\x01\x01\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xda\x01\x08\x15\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xdb\
    \x01\x04\x11\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xdb\x01\x04\t\n\r\n\x05\
    \x04\x0f\x02\0\x01\x12\x04\xdb\x01\n\x0c\n\r\n\x05\x04\x0f\x02\0\x03\x12\
    \x04\xdb\x01\x0f\x10\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xdc\x01\x04\x11\
    \n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xdc\x01\x04\t\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\xdc\x01\n\x0c\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\
    \xdc\x01\x0f\x10\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xdd\x01\x04\x12\n\r\
    \n\x05\x04\x0f\x02\x02\x05\x12\x04\xdd\x01\x04\n\n\r\n\x05\x04\x0f\x02\
    \x02\x01\x12\x04\xdd\x01\x0b\r\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xdd\
    \x01\x10\x11\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\xde\x01\x04\x11\n\r\n\
    \x05\x04\x0f\x02\x03\x05\x12\x04\xde\x01\x04\t\n\r\n\x05\x04\x0f\x02\x03\
    \x01\x12\x04\xde\x01\n\x0c\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xde\x01\
    \x0f\x10\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\xdf\x01\x04\x13\n\r\n\x05\
    \x04\x0f\x02\x04\x05\x12\x04\xdf\x01\x04\x0b\n\r\n\x05\x04\x0f\x02\x04\
    \x01\x12\x04\xdf\x01\x0c\x0e\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xdf\
    \x01\x11\x12\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xe0\x01\x04\x13\n\r\n\
    \x05\x04\x0f\x02\x05\x05\x12\x04\xe0\x01\x04\x0b\n\r\n\x05\x04\x0f\x02\
    \x05\x01\x12\x04\xe0\x01\x0c\x0e\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\
    \xe0\x01\x11\x12\n\x0c\n\x02\x04\x10\x12\x06\xe3\x01\0\xe8\x01\x01\n\x0b\
    \n\x03\x04\x10\x01\x12\x04\xe3\x01\x08\x12\n\x0c\n\x04\x04\x10\x02\0\x12\
    \x04\xe4\x01\x04\x11\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xe4\x01\x04\t\n\
    \r\n\x05\x04\x10\x02\0\x01\x12\x04\xe4\x01\n\x0c\n\r\n\x05\x04\x10\x02\0\
    \x03\x12\x04\xe4\x01\x0f\x10\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xe5\x01\
    \x04\x11\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xe5\x01\x04\t\n\r\n\x05\
    \x04\x10\x02\x01\x01\x12\x04\xe5\x01\n\x0c\n\r\n\x05\x04\x10\x02\x01\x03\
    \x12\x04\xe5\x01\x0f\x10\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xe6\x01\x04\
    )\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xe6\x01\x04\x0c\n\r\n\x05\x04\
    \x10\x02\x02\x06\x12\x04\xe6\x01\r\x1a\n\r\n\x05\x04\x10\x02\x02\x01\x12\
    \x04\xe6\x01\x1b$\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xe6\x01'(\n\x0c\
    \n\x04\x04\x10\x02\x03\x12\x04\xe7\x01\x04\x11\n\r\n\x05\x04\x10\x02\x03\
    \x05\x12\x04\xe7\x01\x04\t\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xe7\x01\
    \n\x0c\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xe7\x01\x0f\x10\n\x0c\n\x02\
    \x04\x11\x12\x06\xea\x01\0\xed\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xea\x01\x08\x0f\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xeb\x01\x04!\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xeb\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\
    \x06\x12\x04\xeb\x01\r\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xeb\x01\
    \x18\x1c\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xeb\x01\x1f\x20\n\x0c\n\x04\
    \x04\x11\x02\x01\x12\x04\xec\x01\x04\x11\n\r\n\x05\x04\x11\x02\x01\x05\
    \x12\x04\xec\x01\x04\t\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xec\x01\n\
    \x0c\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xec\x01\x0f\x10\n\x0c\n\x02\
    \x04\x12\x12\x06\xef\x01\0\xf4\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\
    \xef\x01\x08\x0f\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xf0\x01\x04)\n\r\n\
    \x05\x04\x12\x02\0\x04\x12\x04\xf0\x01\x04\x0c\n\r\n\x05\x04\x12\x02\0\
    \x06\x12\x04\xf0\x01\r\x1a\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf0\x01\
    \x1b$\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xf0\x01'(\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xf1\x01\x04\x11\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xf1\x01\x04\t\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xf1\x01\n\x0c\n\r\n\
    \x05\x04\x12\x02\x01\x03\x12\x04\xf1\x01\x0f\x10\n\x0c\n\x04\x04\x12\x02\
    \x02\x12\x04\xf2\x01\x04\x11\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xf2\
    \x01\x04\t\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xf2\x01\n\x0c\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\xf2\x01\x0f\x10\n\x0c\n\x04\x04\x12\x02\x03\
    \x12\x04\xf3\x01\x04\x11\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xf3\x01\
    \x04\t\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xf3\x01\n\x0c\n\r\n\x05\x04\
    \x12\x02\x03\x03\x12\x04\xf3\x01\x0f\x10\n\x0c\n\x02\x04\x13\x12\x06\xf6\
    \x01\0\xfd\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xf6\x01\x08\x17\n\x0c\
    \n\x04\x04\x13\x02\0\x12\x04\xf7\x01\x04\x17\n\r\n\x05\x04\x13\x02\0\x05\
    \x12\x04\xf7\x01\x04\t\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xf7\x01\n\x12\
    \n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf7\x01\x15\x16\n\x0c\n\x04\x04\x13\
    \x02\x01\x12\x04\xf8\x01\x04\x14\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\
    \xf8\x01\x04\n\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xf8\x01\x0b\x0f\n\r\
    \n\x05\x04\x13\x02\x01\x03\x12\x04\xf8\x01\x12\x13\n\x0c\n\x04\x04\x13\
    \x02\x02\x12\x04\xf9\x01\x04\x13\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\
    \xf9\x01\x04\t\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xf9\x01\n\x0e\n\r\n\
    \x05\x04\x13\x02\x02\x03\x12\x04\xf9\x01\x11\x12\n\x0c\n\x04\x04\x13\x02\
    \x03\x12\x04\xfa\x01\x04\x13\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\xfa\
    \x01\x04\t\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xfa\x01\n\x0e\n\r\n\x05\
    \x04\x13\x02\x03\x03\x12\x04\xfa\x01\x11\x12\n\x0c\n\x04\x04\x13\x02\x04\
    \x12\x04\xfb\x01\x04\x19\n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\xfb\x01\
    \x04\t\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xfb\x01\n\x14\n\r\n\x05\x04\
    \x13\x02\x04\x03\x12\x04\xfb\x01\x17\x18\n\x0c\n\x04\x04\x13\x02\x05\x12\
    \x04\xfc\x01\x04\x19\n\r\n\x05\x04\x13\x02\x05\x05\x12\x04\xfc\x01\x04\t\
    \n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xfc\x01\n\x14\n\r\n\x05\x04\x13\
    \x02\x05\x03\x12\x04\xfc\x01\x17\x18\n\x0c\n\x02\x04\x14\x12\x06\xff\x01\
    \0\x81\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xff\x01\x08\x16\n\x0c\n\
    \x04\x04\x14\x02\0\x12\x04\x80\x02\x04\x19\n\r\n\x05\x04\x14\x02\0\x05\
    \x12\x04\x80\x02\x04\t\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x80\x02\n\x14\
    \n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x80\x02\x17\x18\n\x0c\n\x02\x04\x15\
    \x12\x06\x83\x02\0\x8d\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x83\x02\
    \x08\x1d\n\x0c\n\x04\x04\x15\x02\0\x12\x04\x84\x02\x04\x11\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\x84\x02\x04\t\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \x84\x02\n\x0c\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x84\x02\x0f\x10\n\x0c\
    \n\x04\x04\x15\x02\x01\x12\x04\x85\x02\x04\x14\n\r\n\x05\x04\x15\x02\x01\
    \x05\x12\x04\x85\x02\x04\n\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x85\x02\
    \x0b\x0f\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x85\x02\x12\x13\n\x0c\n\
    \x04\x04\x15\x02\x02\x12\x04\x86\x02\x04\x14\n\r\n\x05\x04\x15\x02\x02\
    \x05\x12\x04\x86\x02\x04\t\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x86\x02\
    \n\x0f\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\x86\x02\x12\x13\n\x0c\n\x04\
    \x04\x15\x02\x03\x12\x04\x87\x02\x04\x15\n\r\n\x05\x04\x15\x02\x03\x05\
    \x12\x04\x87\x02\x04\t\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\x87\x02\n\
    \x0f\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\x87\x02\x12\x14\n\x0c\n\x04\
    \x04\x15\x02\x04\x12\x04\x88\x02\x04\x14\n\r\n\x05\x04\x15\x02\x04\x05\
    \x12\x04\x88\x02\x04\t\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\x88\x02\n\
    \x0e\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\x88\x02\x11\x13\n\x0c\n\x04\
    \x04\x15\x02\x05\x12\x04\x89\x02\x04\x1d\n\r\n\x05\x04\x15\x02\x05\x05\
    \x12\x04\x89\x02\x04\t\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\x89\x02\n\
    \x17\n\r\n\x05\x04\x15\x02\x05\x03\x12\x04\x89\x02\x1a\x1c\n\x0c\n\x04\
    \x04\x15\x02\x06\x12\x04\x8a\x02\x04\x15\n\r\n\x05\x04\x15\x02\x06\x05\
    \x12\x04\x8a\x02\x04\t\n\r\n\x05\x04\x15\x02\x06\x01\x12\x04\x8a\x02\n\
    \x0f\n\r\n\x05\x04\x15\x02\x06\x03\x12\x04\x8a\x02\x12\x14\n\x0c\n\x04\
    \x04\x15\x02\x07\x12\x04\x8b\x02\x04\x18\n\r\n\x05\x04\x15\x02\x07\x05\
    \x12\x04\x8b\x02\x04\t\n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\x8b\x02\n\
    \x12\n\r\n\x05\x04\x15\x02\x07\x03\x12\x04\x8b\x02\x15\x17\n\x0c\n\x04\
    \x04\x15\x02\x08\x12\x04\x8c\x02\x04\x1a\n\r\n\x05\x04\x15\x02\x08\x05\
    \x12\x04\x8c\x02\x04\t\n\r\n\x05\x04\x15\x02\x08\x01\x12\x04\x8c\x02\n\
    \x14\n\r\n\x05\x04\x15\x02\x08\x03\x12\x04\x8c\x02\x17\x19\n\x0c\n\x02\
    \x04\x16\x12\x06\x8f\x02\0\x9c\x02\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\
    \x8f\x02\x08\x17\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x90\x02\x04\x11\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\x90\x02\x04\t\n\r\n\x05\x04\x16\x02\0\x01\
    \x12\x04\x90\x02\n\x0c\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x90\x02\x0f\
    \x10\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x91\x02\x04\x11\n\r\n\x05\x04\
    \x16\x02\x01\x05\x12\x04\x91\x02\x04\t\n\r\n\x05\x04\x16\x02\x01\x01\x12\
    \x04\x91\x02\n\x0c\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x91\x02\x0f\x10\
    \n\x0e\n\x04\x04\x16\x03\0\x12\x06\x92\x02\x04\x98\x02\x05\n\r\n\x05\x04\
    \x16\x03\0\x01\x12\x04\x92\x02\x0c\x1c\n\x0e\n\x06\x04\x16\x03\0\x02\0\
    \x12\x04\x93\x02\x08\x17\n\x0f\n\x07\x04\x16\x03\0\x02\0\x05\x12\x04\x93\
    \x02\x08\r\n\x0f\n\x07\x04\x16\x03\0\x02\0\x01\x12\x04\x93\x02\x0e\x12\n\
    \x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\x93\x02\x15\x16\n\x0e\n\x06\
    \x04\x16\x03\0\x02\x01\x12\x04\x94\x02\x08\x1a\n\x0f\n\x07\x04\x16\x03\0\
    \x02\x01\x05\x12\x04\x94\x02\x08\r\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x01\
    \x12\x04\x94\x02\x0e\x15\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x03\x12\x04\
    \x94\x02\x18\x19\n\x0e\n\x06\x04\x16\x03\0\x02\x02\x12\x04\x95\x02\x08\
    \x1d\n\x0f\n\x07\x04\x16\x03\0\x02\x02\x05\x12\x04\x95\x02\x08\x0e\n\x0f\
    \n\x07\x04\x16\x03\0\x02\x02\x01\x12\x04\x95\x02\x0f\x18\n\x0f\n\x07\x04\
    \x16\x03\0\x02\x02\x03\x12\x04\x95\x02\x1b\x1c\n\x0e\n\x06\x04\x16\x03\0\
    \x02\x03\x12\x04\x96\x02\x08\x1c\n\x0f\n\x07\x04\x16\x03\0\x02\x03\x05\
    \x12\x04\x96\x02\x08\x0e\n\x0f\n\x07\x04\x16\x03\0\x02\x03\x01\x12\x04\
    \x96\x02\x0f\x17\n\x0f\n\x07\x04\x16\x03\0\x02\x03\x03\x12\x04\x96\x02\
    \x1a\x1b\n\x0e\n\x06\x04\x16\x03\0\x02\x04\x12\x04\x97\x02\x08\x1e\n\x0f\
    \n\x07\x04\x16\x03\0\x02\x04\x05\x12\x04\x97\x02\x08\r\n\x0f\n\x07\x04\
    \x16\x03\0\x02\x04\x01\x12\x04\x97\x02\x0e\x19\n\x0f\n\x07\x04\x16\x03\0\
    \x02\x04\x03\x12\x04\x97\x02\x1c\x1d\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\
    \x99\x02\x04*\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\x99\x02\x04\x14\n\r\
    \n\x05\x04\x16\x02\x02\x01\x12\x04\x99\x02\x15%\n\r\n\x05\x04\x16\x02\
    \x02\x03\x12\x04\x99\x02()\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\x9a\x02\
    \x04\x17\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\x9a\x02\x04\t\n\r\n\x05\
    \x04\x16\x02\x03\x01\x12\x04\x9a\x02\n\x11\n\r\n\x05\x04\x16\x02\x03\x03\
    \x12\x04\x9a\x02\x14\x16\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\x9b\x02\x04\
    \x13\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\x9b\x02\x04\t\n\r\n\x05\x04\
    \x16\x02\x04\x01\x12\x04\x9b\x02\n\r\n\r\n\x05\x04\x16\x02\x04\x03\x12\
    \x04\x9b\x02\x10\x12b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
